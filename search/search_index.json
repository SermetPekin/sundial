{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sundial Calculations","text":"<p>This notebook accompanies my sundial paper. I originally used Maple for the calculations, but decided to reproduce them here to make the analysis more accessible, and as a way to learn SymPy and GAlgebra. I used my cheat sheet for Geometric Algebra at various points.</p> <p>I haven't reproduced the orbit analysis, equation of time or plots of the shadow tip yet, but plan to add them in the future. For now, however, all the main results are reproduced here.</p> <p>Run the notebook yourself: </p> <pre><code>import sympy as sp\nfrom sympy import sin, cos, tan\nfrom sympy.abc import *\nfrom galgebra import mv\nfrom galgebra.ga import Ga\nfrom galgebra.printer import latex\nfrom IPython.display import Math\n\nsp.init_printing()\n\n# Multivector mv on its own in a cell appears fine in the notebook but when nbconverted\n# to Markdown comes out as \\begin{equation*} x \\end{equation*} instead of eg $\\displaystyle x$\n# and consequently isn't rendered in HTML after running mkdocs.\ndef display(mv):\n    return(Math(latex(mv)))\n</code></pre>"},{"location":"#setup-and-definitions","title":"Setup and Definitions","text":""},{"location":"#fixed-stars-frame","title":"Fixed Stars Frame","text":"<p>First, we define the geometric algebra of 3-space and some basis blades from the frame of the \"fixed stars\"</p> <p>.</p> <pre><code>coords = sp.symbols('1 2 3', real=True)\nG3 = Ga('e', g=[1,1,1], coords=coords)\n\n(e1, e2, e3) = G3.mv()\nI = e1^e2^e3\n</code></pre>"},{"location":"#earth-frame","title":"Earth Frame","text":"<p>Now, let the tilt of the earth's plane (axis) of rotation be \\(\\alpha\\) and measure the earth's rotation by \\(\\psi\\). Then we can define the Earth frame as follows.</p> <pre><code>def rotate(mv, angle, bivec):\n    rotor = ( cos(angle/2) - (bivec) * sin(angle/2) ).trigsimp()\n    return ( rotor * mv * rotor.rev() )\n\ne1_prime = rotate(e1, alpha, e1^e3).trigsimp()\n\nf1 = rotate(e1_prime, psi, e1_prime^e2).trigsimp().trigsimp()\nf2 = rotate(e2, psi, e1_prime^e2).trigsimp().trigsimp()\nf3 = rotate(e3, alpha, e1^e3).trigsimp().trigsimp()\n\ndef print_3frame(frame, symbol):\n    return Math(fr'''\n            \\begin{{align}}\n            {symbol}_1 &amp;= {latex(frame[0])} \\nonumber \\\\\n            {symbol}_2 &amp;= {latex(frame[1])} \\nonumber \\\\\n            {symbol}_3 &amp;= {latex(frame[2])} \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_3frame((f1,f2,f3), \"f\")\n</code></pre> \\[\\displaystyle              \\begin{align}             f_1 &amp;= \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             f_2 &amp;= - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             f_3 &amp;= - \\sin{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{3} \\nonumber             \\end{align}             \\] <p>Check that this is an orthonormal frame</p> <pre><code>result = (e1 ^ e2 ^ e3) - (f1 * f2 * f3)\n\nassert result.obj.equals(0)\ndisplay(result)\n</code></pre> \\[\\displaystyle  0 \\] <p>The equatorial plane should only depend on the tilt of the Earth's axis of spin \\(\\alpha\\), not the angle by which it has rotated relative to the fixed stars \\(\\psi\\).</p> <pre><code># would like to use mv.Fmt but it seems to give LaTeX output which doesn't render after eg jupyter nbconvert --to Markdown\ndef print_eq(lhs : str, rhs : sp.Symbol):\n    return Math(fr'''\n        \\begin{{equation}}\n            {lhs} = {latex(rhs)} \\nonumber\n        \\end{{equation}}\n        ''')\n\nprint_eq(r\"f_1 \\wedge f_2\", (f1^f2))\n</code></pre> \\[\\displaystyle          \\begin{equation}             f_1 \\wedge f_2 = \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\]"},{"location":"#surface-frame","title":"Surface Frame","text":"<p>Define an orthonormal frame embedded in the Earth's surface, with \\(n_1\\) pointing South, \\(n_2\\) pointing East and \\(n_3\\) pointing up.</p> <p>.</p> <pre><code>n1 = rotate(f1, theta, f3^f1).trigsimp().trigsimp()\nn2 = f2\n\n# n3 needs a little love\nraw_n3 = rotate(f3, theta, f3^f1).obj.trigsimp()\nsympy_n3 = sp.expand(sp.expand_trig(raw_n3)) # galgebra's Mv doesn't have expand_trig as a method\nn3 = mv.Mv(sympy_n3, ga=G3)\n\nprint_3frame((n1,n2,n3), \"n\")\n</code></pre> \\[\\displaystyle              \\begin{align}             n_1 &amp;= \\left ( \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )}\\right ) \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber \\\\             n_2 &amp;= - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             n_3 &amp;= \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\theta  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber             \\end{align}             \\] <p>Check that this basis is orthnormal. Geometric product of the \\(\\{n_i\\}\\) should give the pseudoscalar \\(I = e_1 \\wedge e_2 \\wedge e_3\\)</p> <pre><code>n123 = (n1*n2*n3).trigsimp()\nassert n123.obj.equals((e1*e2*e3).obj)\ndisplay(n123)\n</code></pre> \\[\\displaystyle  \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\]"},{"location":"#orbit-rotor-and-meridian-plane","title":"Orbit Rotor and Meridian Plane","text":"<p>Earth orbit rotor \\(R_\\sigma\\), and vector parallel to rays of sunshine, \\(s\\).</p> <pre><code>s = rotate(e1, sigma, e1^e2).trigsimp()\nprint_eq(\"s\", s)\n</code></pre> \\[\\displaystyle          \\begin{equation}             s = \\cos{\\left (\\sigma  \\right )} \\boldsymbol{e}_{1} + \\sin{\\left (\\sigma  \\right )} \\boldsymbol{e}_{2} \\nonumber         \\end{equation}         \\] <p>The meridian plane, \\(M\\).</p> <pre><code>M = (n1^n3).trigsimp()\nprint_eq(\"M\", M)\n</code></pre> \\[\\displaystyle          \\begin{equation}             M = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{3} + \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\] <p>The noon line is the intersection of the sunshine vector \\(s\\) and the meridian plane \\(M\\), which occurs where \\(s \\wedge M\\) vanishes.</p> <pre><code>display( (s^M).trigsimp() )\n</code></pre> \\[\\displaystyle \\left ( \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\] <pre><code>coeff = (s^M).trigsimp().get_coefs(3)[0]\nsoln = sp.solve(coeff.subs(sin(psi), tan(psi)*cos(psi)), tan(psi))[0]\n\nassert soln.equals(tan(sigma)/cos(alpha))\nprint_eq( r\"\\tan(\\psi)\", soln )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\psi) = \\frac{\\tan{\\left (\\sigma  \\right )}}{\\cos{\\left (\\alpha  \\right )}} \\nonumber         \\end{equation}         \\]"},{"location":"#dial-face-and-gnomon","title":"Dial face and gnomon","text":"<p>Define an orthnormal frame \\(u_1, u_2, u_3\\) as the unevaluated version of \\(n_1, n_2, n_3\\).</p> <p>.</p> <pre><code>G3u = Ga('u', g=[1,1,1], coords=coords)\n\n(u1, u2, u3) = G3u.mv()\nU = u1^u2^u3\ndisplay(U)\n</code></pre> \\[\\displaystyle  \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3}\\] <p>Dial face expressed relative to \\(u\\) basis: \\(G_u\\).</p> <pre><code>Gu = rotate(rotate(u1^u2, i, u1^u3), d, u1^u2).trigsimp()\nprint_eq( \"G_u\", Gu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             G_u = \\cos{\\left (i \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{3} - \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Frame embedded in dial face.</p> <pre><code>m1 = rotate(rotate(u1, i, u1^u3), d, u1^u2).trigsimp()\nm2 = rotate(rotate(u2, i, u1^u3), d, u1^u2)\nm3 = rotate(rotate(u3, i, u1^u3), d, u1^u2).trigsimp()\n\nprint_3frame((m1,m2,m3), \"m\")\n</code></pre> \\[\\displaystyle              \\begin{align}             m_1 &amp;= \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\boldsymbol{u}_{1} + \\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\boldsymbol{u}_{2} + \\sin{\\left (i \\right )} \\boldsymbol{u}_{3} \\nonumber \\\\             m_2 &amp;= - \\sin{\\left (d \\right )} \\boldsymbol{u}_{1} + \\cos{\\left (d \\right )} \\boldsymbol{u}_{2} \\nonumber \\\\             m_3 &amp;= - \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\boldsymbol{u}_{1} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\boldsymbol{u}_{2} + \\cos{\\left (i \\right )} \\boldsymbol{u}_{3} \\nonumber             \\end{align}             \\] <p>The gnomon expressed relative to the \\(u\\) frame, \\(g_u\\).</p> <p>.</p> <pre><code>gu = rotate(rotate(u3, iota, u1^u3), delta, u1^u2).trigsimp()\n\n# extra manipulation to display exactly as in paper\nprint_eq(\"g_u\", sp.collect(sp.trigsimp(gu.obj), -sin(iota)))\n</code></pre> \\[\\displaystyle          \\begin{equation}             g_u = - \\sin{\\left (\\iota  \\right )} \\left(\\sin{\\left (\\delta  \\right )} \\boldsymbol{u}_{2} + \\cos{\\left (\\delta  \\right )} \\boldsymbol{u}_{1}\\right) + \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Projected onto the fixed-stars basis, the gnomon is</p> <pre><code>g = sum([ c*ni for c, ni in zip(gu.get_coefs(1),[n1, n2, n3])])\ng = g.trigsimp()\n\n# would like to use .Fmt(3) but having rendering issues\ndef print_vec(lhs, vec, symbol=\"e\", func=lambda x: x):\n    coeffs = vec.get_coefs(1)\n    return Math(fr'''\n            \\begin{{align}}\n            {lhs} &amp; = {latex(func(coeffs[0]))} {symbol}_1 \\nonumber \\\\\n            &amp; + {latex(func(coeffs[1]))} {symbol}_2 \\nonumber \\\\\n            &amp; + {latex(func(coeffs[2]))} {symbol}_3 \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_vec(\"g\", g)\n</code></pre> \\[\\displaystyle              \\begin{align}             g &amp; = - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\delta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} - \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} e_2 \\nonumber \\\\             &amp; + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} e_3 \\nonumber             \\end{align}             \\] <p>The gnomon lies in the meridian plane when the following trivector vanishes:</p> <pre><code>M_wedge_g = M^g\nassert M_wedge_g.obj.trigsimp().equals((sin(delta)*sin(iota)*e1^e2^e3).obj)\ndisplay( M_wedge_g )\n</code></pre> \\[\\displaystyle \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\] <p>Will also want \\(s\\) on the \\(n\\) frame</p> <pre><code>coeffs = [sp.trigsimp((s|c).obj) for c in [n1, n2, n3]]\nsu = sum([coeff*vec for coeff, vec in zip(coeffs, [u1, u2, u3])])\nprint_vec(\"s_u\", su, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             s_u &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} u_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} u_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} u_3 \\nonumber             \\end{align}             \\]"},{"location":"#the-calculation","title":"The Calculation","text":"<p>Work in the case where its declination angle \\(\\delta\\) is zero.</p> <pre><code>gu_delta = gu\ngu = gu.subs(delta, 0)\nprint_eq( \"g_u\", gu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             g_u = - \\sin{\\left (\\iota  \\right )} \\boldsymbol{u}_{1} + \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <pre><code>g_delta = g\ng = g.subs(delta, 0)\nprint_eq( \"g\", g)\n</code></pre> \\[\\displaystyle          \\begin{equation}             g = \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\] <p><code>g.obj</code> trails behind by one trigsimp</p> <pre><code>display( g.obj )\n</code></pre> \\[\\displaystyle \\left(- \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\boldsymbol{e}_{2} + \\left(- \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\boldsymbol{e}_{1} + \\left(- \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\boldsymbol{e}_{3}\\] <p>Hack: ensure a healthy <code>g.obj</code> by reforming \\(g\\) from the result of applying <code>sympy.trigsimp</code> to each component individually</p> <pre><code>g = sum([sp.trigsimp(coef)*vec for coef, vec in zip(g.get_coefs(1), G3.mv())])\ndisplay( g )\n</code></pre> \\[\\displaystyle \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right ) \\boldsymbol{e}_{3}\\] <pre><code># eyeball check:\ndisplay( g.obj )\n</code></pre> \\[\\displaystyle - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{3}\\]"},{"location":"#the-shadow-plane","title":"The Shadow Plane","text":"<p>\\(S = s \\wedge g\\) is the plane containing the sunshine vector and the gnomon.</p> <pre><code>S = s^g\n\ndef print_bivec(lhs, bivec, symbol=\"e\"):\n    coeffs = bivec.get_coefs(2)\n    return Math(fr'''\n            \\begin{{align}}\n            {lhs} &amp; = {latex(coeffs[0])} {symbol}_1 \\wedge {symbol}_2 \\nonumber \\\\\n            &amp; + {latex(coeffs[1])} {symbol}_1 \\wedge {symbol}_3 \\nonumber \\\\\n            &amp; + {latex(coeffs[2])} {symbol}_2 \\wedge {symbol}_3 \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_bivec(\"S\", S)\n</code></pre> \\[\\displaystyle              \\begin{align}             S &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\wedge e_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_1 \\wedge e_3 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_2 \\wedge e_3 \\nonumber             \\end{align}             \\] <p>Cosine of angle \\(\\Xi\\) between sun ray and gnomon:</p> <pre><code>cosXi = sp.trigsimp((s|g).obj)\nprint_eq(r\"\\cos(\\Xi)\", cosXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\Xi) = - \\left(\\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} + \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\nonumber         \\end{equation}         \\] <p>Check \\(S^2 = (s\\wedge g)^2 = (s\\cdot g)^2 - s^2 g^2\\) where \\(s^2 = g^2 = 1\\). </p> <pre><code>sg_squared = (s|g)*(s|g)\nS_norm_check = (S|S) - ( sg_squared - 1 )\nassert S_norm_check.obj.equals(0)\ndisplay( S_norm_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>The magnitude of \\(S\\) is given by \\(\\sqrt{-S^2} = \\sqrt{1 - (s\\cdot g)^2} = \\sqrt{1 - \\cos^2(\\Xi}) = \\sin^2(\\Xi)\\):</p> <pre><code>sinXi = sp.sqrt( 1 - ((cos(alpha)*cos(sigma)*cos(psi) + sin(sigma)*sin(psi))*sin(iota-theta) + sin(alpha)*cos(sigma)*cos(iota-theta))**2 )\nprint_eq(\"\\sin(\\Xi)\", sinXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) = \\sqrt{1 - \\left(\\left(\\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}\\right) \\sin{\\left (\\iota  - \\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right)^{2}} \\nonumber         \\end{equation}         \\] <pre><code># check\nsg_check = sinXi**2 - ( 1 - sg_squared )\nassert sg_check.obj.equals(0)\ndisplay( sg_check )\n</code></pre> \\[\\displaystyle  0 \\]"},{"location":"#the-hour-angle","title":"The Hour Angle","text":"<p>Define a generalized solar hour angle \\(\\mu\\) as the angle between \\(S\\) and \\(M\\), given by</p> \\[\\cos(\\mu) = \\frac{-S\\cdot M}{\\sqrt{-S^2}\\sqrt{-M^2}} = \\frac{-S\\cdot M}{\\sin(\\Xi)}\\] <p>given that \\(M^2=-1\\)</p> <pre><code>sinXi_cos_mu = sp.trigsimp(-(S|M).obj)\n\nprint_eq( r\"\\sin(\\Xi) \\cos(\\mu)\", sinXi_cos_mu )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) \\cos(\\mu) = - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\nonumber         \\end{equation}         \\] <p>From \\(\\sin^2\\mu + \\cos^2\\mu = 1\\) (by hand), we have:</p> <pre><code>sinXi_sin_mu = cos(alpha)*sin(psi)*cos(sigma) - cos(psi)*sin(sigma)\nprint_eq(\"\\sin(\\Xi) \\sin(\\mu)\", sinXi_sin_mu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) \\sin(\\mu) = \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} \\nonumber         \\end{equation}         \\] <p>Check that \\(\\sin^2(\\Xi)\\sin^2(\\mu) + \\sin^2(\\Xi)\\cos^2(\\mu) = \\sin^2(\\Xi)\\)</p> <pre><code>Xi_check = sp.trigsimp( sp.expand(sinXi_sin_mu**2) + sp.expand(sinXi_cos_mu**2) - sp.expand(sinXi**2) )\nassert Xi_check.equals(0)\ndisplay( Xi_check )\n</code></pre> \\[\\displaystyle 0\\] <p>The ratio gives \\(\\tan(\\mu)\\) as in the paper:</p> <pre><code>mu_ratio = sinXi_sin_mu / sp.collect(sinXi_cos_mu, cos(iota-theta))\nprint_eq( r\"\\tan(\\mu)\", sp.simplify( mu_ratio.subs(sin(sigma), tan(sigma)*cos(sigma)) ) )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\mu) = \\frac{\\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\cos{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )}}{\\left(\\sin{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )}} \\nonumber         \\end{equation}         \\] <p>Now express \\(S\\) in terms of \\(\\mu\\) on the \\(\\{n\\}\\) basis. First remind myself what \\(S\\) looks like:</p> <pre><code>print_bivec(\"S\", S)\n</code></pre> \\[\\displaystyle              \\begin{align}             S &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\wedge e_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_1 \\wedge e_3 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_2 \\wedge e_3 \\nonumber             \\end{align}             \\] <p>and save nice forms of the \\(n\\) bivectors</p> <pre><code>n12 = mv.Mv(sp.trigsimp(sp.expand_trig((n1^n2).obj)), ga=G3)\nn13 = mv.Mv(sp.trigsimp(sp.expand_trig((n1^n3).obj)), ga=G3)\nn23 = mv.Mv(sp.trigsimp(sp.expand_trig((n2^n3).obj)), ga=G3)\n</code></pre> <p>So now can check each component of S on the \\(n\\) basis</p> <pre><code>Sn_check = (S|n12) + (-sinXi_sin_mu*sin(iota)) == (S|n13) + sinXi_cos_mu == (S|n23) + (-sinXi_sin_mu*cos(iota)) == mv.Mv(0, ga=G3)\nassert Sn_check\nSn_check\n</code></pre> <pre><code>True\n</code></pre> <p>and confirm S in this form</p> <pre><code>S_check = S - (-sinXi_sin_mu*(sin(iota)*n12 + cos(iota)*n23) + sinXi_cos_mu*n13)\nassert S_check.obj.equals(0)\ndisplay( S_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>so can capture S in terms of the surface-frame bivectors</p> <pre><code>Xi = sp.Symbol(\"\\Xi\")\nSu = sin(Xi)*( -sin(mu) * (sin(iota)*(u1^u2) + cos(iota)*(u2^u3)) + cos(mu)*(u1^u3) )\nprint_eq( \"S_u\", Su)\n</code></pre> \\[\\displaystyle          \\begin{equation}             S_u = - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2} + \\sin{\\left (\\Xi \\right )} \\cos{\\left (\\mu  \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{3} - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Check that \\(S_u\\) and \\(S\\) are really the same thing</p> <pre><code>def e_frame(bvec):\n    \"\"\"\n    Take a bivector in the GA defined by the surface frame n1, n2, n3 (written as u1, u2, u3)\n    and express it in the GA defined by the frame of the fixed stars, e1, e2, e3\n    \"\"\"\n    coeffs = bvec.get_coefs(2)\n    return coeffs[0]*n12 + coeffs[1]*n13 + coeffs[2]*n23\n\nSu_check = e_frame(Su).subs(sin(mu), sinXi_sin_mu/sin(Xi)).subs(cos(mu), sinXi_cos_mu/sin(Xi)) - S\nassert Su_check.obj.equals(0)\ndisplay( Su_check )\n</code></pre> \\[\\displaystyle  0 \\]"},{"location":"#the-shadow-angle","title":"The Shadow Angle","text":"<p>Form a vector parallel to the shadow, as the intersection between \\(S\\) (the plane containing the sun ray and the gnomon) and \\(G\\) (the dial face)</p> <pre><code>u = ((u1^u2^u3) * Gu * Su).get_grade(1).trigsimp()\nprint_vec(\"u\", u, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             u &amp; = \\sin{\\left (\\Xi \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\sin{\\left (\\Xi \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} u_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\Xi \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )} u_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\Xi \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\Xi \\right )} \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )} u_3 \\nonumber             \\end{align}             \\] <p>Want to normalize \\(u\\) to get \\(\\hat{u} \\equiv \\hat{w}\\), a unit vector parallel to the shadow \\(w\\). Can square and add the above components, but there is a route to a simpler expression as follows.</p> <p>The cosine of the angle between the \"shadow plane\" \\(S\\) (containing the sun ray \\(s\\) and the gnomon \\(g\\)) and dial face \\(G\\) is given by</p> \\[\\cos(\\Psi) = \\frac{S\\cdot G}{\\sqrt{-S^2}\\sqrt{-G^2}}\\] <p>Given that \\(S^2 = -\\sin^2(\\Xi)\\) and \\(G^2 = -1\\),</p> \\[ \\cos(\\Psi) = \\frac{S\\cdot G}{\\sin(\\Xi)}\\] <pre><code>cosPsi = sp.trigsimp(((Su|Gu)/sin(Xi)).obj)\nprint_eq(r\"\\cos(\\Psi)\", cosPsi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\Psi) = - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (i \\right )} \\nonumber         \\end{equation}         \\] <pre><code># check (force sympy to give up the positive square root in each factor in the denominator)\nSuGu_check = sp.trigsimp((Su|Gu).obj) \\\n/ sp.powdenest(sp.sqrt(sp.trigsimp((-Su|Su).obj)), force=True) \\\n/ sp.powdenest(sp.sqrt(sp.trigsimp((-Gu|Gu).obj)), force=True) \\\n- ((Su|Gu)/sin(Xi))\nassert SuGu_check.obj.equals(0)\ndisplay( SuGu_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Now, the length of \\(u\\) is related to \\(\\Psi\\) as follows.</p> \\[u^2 = (I\\; G \\times S)^2 = (\\frac{I}{2}(GS-SG))^2 = -\\frac{1}{4}(GSGS+SGSG-2S^2G^2)\\] <p>But</p> \\[(S\\cdot G)^2 = \\frac{1}{4}(SG+GS)^2 = \\frac{1}{4}(SGSG+GSGS+2S^2G^2)\\] <p>So,</p> \\[u^2 = S^2G^2 - (S\\cdot G)^2 = \\sin^2(\\Xi) - (S\\cdot G)^2 = \\sin^2(\\Xi)\\sin^2(\\Psi)\\] <pre><code># check\nu2_check = (u|u) - (sin(Xi)**2 - (Su|Gu)**2)\nassert u2_check.obj.equals(0)\ndisplay( u2_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>We can now form \\(\\hat{w}\\) by dividing \\(u\\) by its length</p> <pre><code>Psi = sp.Symbol(\"\\Psi\")\nwhat = u/sin(Xi)/sin(Psi)\n\nprint_vec(r\"\\hat{w}\", what, \"u\", sp.factor)\n</code></pre> \\[\\displaystyle              \\begin{align}             \\hat{w} &amp; = \\frac{\\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} u_1 \\nonumber \\\\             &amp; + - \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} u_2 \\nonumber \\\\             &amp; + \\frac{\\left(- \\sin{\\left (d \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )}\\right) \\sin{\\left (i \\right )}}{\\sin{\\left (\\Psi \\right )}} u_3 \\nonumber             \\end{align}             \\] <p>Check that</p> \\[\\hat{w}^2 = \\left(\\frac{u}{\\sin(\\Xi)\\sin(\\Psi)}\\right)^2 = 1\\] <p>by showing that</p> \\[\\frac{u^2}{\\sin^2(\\Xi)} - \\sin^2\\Psi = 0\\] <pre><code>sinPsiSquared = 1 - sp.expand(cosPsi**2)\nu_over_sinXi_squared = sp.trigsimp(((u|u)/sin(Xi)**2).obj)\nwhat_check = sp.trigsimp(u_over_sinXi_squared - sinPsiSquared)\nassert what_check.equals(0)\ndisplay( what_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Get the angular coordinate of the shadow tip relative to noon, call it \\(\\zeta\\). At noon we have \\(\\mu = 0\\)</p> <pre><code>sinPsi_noon = sp.sqrt(1-cosPsi**2).subs(mu,0)\ndisplay( sinPsi_noon )\n</code></pre> \\[\\displaystyle \\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}\\] <pre><code>noon = what.subs(sin(Psi),sinPsi_noon).subs(mu,0)\ndisplay( noon )\n</code></pre> \\[\\displaystyle \\frac{\\cos{\\left (i \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}} \\boldsymbol{u}_{1} + \\frac{\\sin{\\left (i \\right )} \\cos{\\left (d \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}} \\boldsymbol{u}_{3}\\] <p>So \\(\\cos(\\zeta) = \\hat{w}(\\mu) \\cdot \\hat{w}(0)\\)</p> <pre><code>cos_zeta = sp.collect(sp.collect(sp.trigsimp((what|noon).obj),sin(mu)*sin(i)*sin(d)),cos(mu))\nprint_eq( r\"\\cos(\\zeta)\", cos_zeta )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\zeta) = \\frac{\\left(- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1\\right) \\cos{\\left (\\mu  \\right )} + \\left(- \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1} \\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <p>And easiest route to \\(\\sin(\\zeta)\\) is to use the fact that the shadow lives in the plane of the dial face, so \\(\\hat{w}(\\mu) \\wedge \\hat{w}(0) = \\sin(\\zeta) G\\)</p> <pre><code>sin_zeta = -(what ^ noon) | Gu\nprint_eq(r\"\\sin(\\zeta)\", sin_zeta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\zeta) = \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\mu  \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1} \\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>tan_zeta = (sin_zeta/cos_zeta).subs(sin(mu), tan(mu)*cos(mu))\nprint_eq(r\"\\tan(\\zeta)\", tan_zeta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\zeta) = - \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\tan{\\left (\\mu  \\right )}}{{\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + \\sin{\\left (d \\right )} {\\sin{\\left (i \\right )}}^{2} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} \\tan{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )} \\tan{\\left (\\mu  \\right )} - 1} \\nonumber         \\end{equation}         \\] <p>Check that \\(\\sin^2(\\zeta) + \\cos^2(\\zeta) = 1\\)</p> <pre><code>sp.simplify(sp.expand( sp.trigsimp(sin_zeta.obj)**2 + cos_zeta**2 ))\n</code></pre> \\[\\displaystyle \\frac{- \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} + 2 \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\mu \\right)} - \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} - 2 \\sin{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin{\\left(\\mu \\right)} \\cos{\\left(d \\right)} \\cos{\\left(\\iota \\right)} \\cos{\\left(\\mu \\right)} + 2 \\sin{\\left(d \\right)} \\sin{\\left(i \\right)} \\sin{\\left(\\iota \\right)} \\sin{\\left(\\mu \\right)} \\cos{\\left(i \\right)} \\cos{\\left(\\mu \\right)} + 2 \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} - \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\mu \\right)} + 2 \\sin{\\left(i \\right)} \\sin{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} \\cos{\\left(d \\right)} \\cos{\\left(i \\right)} \\cos{\\left(\\iota \\right)} - \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} + 1}{\\sin^{2}{\\left(\\Psi \\right)}}\\] <p>This is 1 if the numerator is equal to the denominator, and we have an explicit expression for \\(\\cos(\\Psi) = \\sqrt{1 - \\sin^2(\\Psi)}\\). So should get zero from the following:</p> <pre><code>zeta_check = sp.trigsimp(sp.numer(_) - (1-cosPsi**2))\nassert zeta_check.equals(0)\ndisplay( zeta_check )\n</code></pre> \\[\\displaystyle 0\\]"},{"location":"#the-shadow-length","title":"The Shadow Length","text":"<p>We have the angle of the shadow vector \\(w\\). Now find the length. Form \\(w(p) = g + p*s\\) and enforce \\(w(p) \\wedge G = 0\\) (used \\(\\lambda\\) instead of \\(p\\) in the paper but can't here because it's a keyword in Python).</p> <pre><code>G = e_frame(Gu)\ntriangle_condition = ((g + p*s)^G) * I\ndisplay( triangle_condition )\n</code></pre> \\[\\displaystyle p \\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - p \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + p \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + p \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - p \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} - \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\] <pre><code>p_soln = sp.solve(sp.trigsimp(triangle_condition.obj), p)[0]\ndisplay( p_soln )\n</code></pre> \\[\\displaystyle \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}}\\] <p>We can write this is in terms of the hour angle \\(\\mu\\) evaluated under the condition \\(\\iota = \\theta\\) and denoted \\(\\mu_s\\). This is true when the gnomon is parallel to the earth's axis, and termed a style, hence the subscript \\(s\\).</p> <pre><code>mu_s = sp.Symbol(r\"\\mu_s\")\nD_soln = sin(Xi) * ((sin(i)*cos(d)*cos(theta)-cos(i)*sin(theta)) * cos(mu_s) - sin(i)*sin(d)*sin(mu_s)) + sin(alpha)*cos(sigma)*( sin(i)*sin(theta)*cos(d) + cos(i)*cos(theta) )\ndisplay( D_soln )\n</code></pre> \\[\\displaystyle \\left(\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu_{s} \\right )} - \\sin{\\left (\\mu_{s} \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )}\\right) \\sin{\\left (\\Xi \\right )} + \\left(\\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )}\\] <pre><code># check\nD_check = sp.simplify(sp.denom(p_soln) - D_soln.subs(mu_s,mu).subs(sin(mu),sinXi_sin_mu/sin(Xi)).subs(cos(mu),sinXi_cos_mu/sin(Xi)).subs(iota,theta))\nassert D_check.equals(0)\ndisplay( D_check )\n</code></pre> \\[\\displaystyle 0\\] <p>So given \\(p\\), we have \\(w = g + ps\\). However, it is a little cumbersome to work with and we can get \\(w\\) in terms of \\(g\\)-\\(ps\\)-\\(w\\) triangle directly by projecting \\(w\\) onto \\(s\\) and \\(g\\) to give two equations we can solve for \\(p\\) and \\(L\\), the length of \\(w\\). We have</p> \\[s\\cdot w = L\\cos(\\Xi-\\beta) = s\\cdot g + p\\, s\\cdot s = \\cos(\\Xi) + p\\] <p>and</p> \\[g\\cdot w = L\\cos(\\beta) = g\\cdot g + p g\\cdot s = 1 + p\\, \\cos(\\Xi)\\] <p>This yields two simultaneous equations for \\(p\\) and \\(L\\), with solutions</p> \\[p = \\frac{\\sin(\\beta)}{\\sin(\\Xi-\\beta)}\\] <p>and</p> \\[L = \\frac{\\sin(\\Xi)}{\\sin(\\Xi-\\beta)}\\] <p>First define \\(w\\) on the \\(n\\) basis</p> <pre><code>wu = gu + p*su\nprint_vec(\"w\", wu, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             w &amp; = p \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + p \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\iota  \\right )} u_1 \\nonumber \\\\             &amp; + - p \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} u_2 \\nonumber \\\\             &amp; + - p \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} + p \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\iota  \\right )} u_3 \\nonumber             \\end{align}             \\] <p>Then check that \\(p + \\cos(\\Xi)\\) is equal to the projection of \\(w\\) onto \\(s\\)</p> <pre><code>ws_check = (su|wu) - (p + cosXi)\nassert ws_check.obj.equals(0)\ndisplay( ws_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Now check that \\(1 + p\\cos(\\Xi)\\) is equal to the projection of \\(w\\) onto \\(g\\)</p> <pre><code>wg_check = (gu|wu) - (1 + p*cosXi)\nassert wg_check.obj.equals(0)\ndisplay( wg_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Given that \\(\\sin(\\beta)\\) appears in the solution for \\(p\\), it will be useful to have its explicit form, which is</p> <pre><code>sin_beta = (sin(i)*sin(iota)*cos(d) + cos(i)*cos(iota))/sin(Psi)\nprint_eq(r\"\\sin(\\beta)\", sin_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\beta) = \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <p>Confirm this by checking that \\(\\sin^2(\\beta) + \\cos^2(\\beta) - 1 = 0\\)</p> <pre><code>cos_beta = sp.collect(sp.trigsimp((gu|what).obj), cos(mu))\nprint_eq(r\"\\cos(\\beta)\", cos_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\beta) = \\frac{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>beta_check = sp.trigsimp(sp.expand(sp.numer(sin_beta)**2 + sp.numer(cos_beta)**2) - (1-cosPsi**2))\nassert beta_check.equals(0)\ndisplay( beta_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Give \\(\\tan(\\beta)\\) as in the paper</p> <pre><code>print_eq(r\"\\tan(\\beta)\", sin_beta/cos_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\beta) = \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}} \\nonumber         \\end{equation}         \\] <p>We can now use the form of \\(p\\) found by solving \\(w\\wedge G = 0\\) to obtain \\(\\sin(\\Xi)\\). First note that \\(N\\), the numerator of \\(p\\), is related to \\(\\beta\\) via</p> \\[\\sin(\\beta) = \\frac{N}{\\sin(\\Psi)}\\] <p>Check</p> <pre><code>sin_beta_check = sp.numer(p_soln)/sin(Psi) - sin_beta\nassert sin_beta_check.equals(0)\ndisplay( sin_beta_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Given our solution for \\(p\\), we can write</p> \\[p = \\frac{\\sin(\\beta)}{\\sin(\\Xi-\\beta)} = \\frac{N}{D}\\] <p>Eliminating \\(N\\) using the above relationship with \\(\\beta\\) and solving for \\(D\\) gives</p> \\[D = \\sin(\\Psi)\\sin(\\Xi-\\beta)\\] <p>Note that using this to eliminate \\(\\sin(\\Xi-\\beta)\\) in our solution for \\(L\\) gives</p> \\[L = \\frac{\\sin(\\Xi)\\sin(\\Psi)}{D}\\] <p>Expanding the double angle in \\(D\\) and solving for \\(\\sin(\\Xi)\\) gives</p> \\[\\sin(\\Xi) = \\frac{D + N\\cos(\\Xi)}{B}\\] <p>where</p> \\[\\cos(\\beta) = \\frac{B}{\\sin(\\Psi)}\\] <p>Thus</p> <pre><code>tmp = (sp.denom(p_soln) + sin(beta)*sin(Psi)*cos(Xi))/(cos(beta)*sin(Psi))\nsinXi = tmp.subs(sin(beta),sin_beta).subs(cos(beta),cos_beta)\nprint_eq( r\"\\sin(\\Xi)\", sinXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) = \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\cos{\\left (\\Xi \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}}{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}} \\nonumber         \\end{equation}         \\]"},{"location":"#the-shadow-coordinates","title":"The Shadow Coordinates","text":"<p>Let's now get the cartesian coordinates of the shadow tip in the dial face frame.</p> \\[w = L \\hat{w}\\] <p>and so can work with \\(\\hat{w}\\) and scale up by after.</p> <pre><code>print_eq(r\"\\frac{x}{L}\", what|m1)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{x}{L} = \\frac{- \\sin{\\left (d \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>print_eq(r\"\\frac{y}{L}\", mv.Mv(sp.trigsimp(sp.expand_trig((what|m2).obj)), ga=G3u))\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{y}{L} = - \\frac{\\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>print_eq(r\"\\frac{z}{L}\", what|m3)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{z}{L} =  0  \\nonumber         \\end{equation}         \\] <p>Check:</p> <pre><code>assert (what|m1).obj.trigsimp().equals((-sin(d)*sin(mu)*cos(iota)+cos(d)*cos(mu))/sin(Psi))\nassert (what|m2).obj.trigsimp().equals(-(sin(d)*cos(i)*cos(mu)+sin(i)*sin(iota)*sin(mu)+sin(mu)*cos(d)*cos(i)*cos(iota))/sin(Psi))\nassert (what|m3).obj.trigsimp().equals(0)\n</code></pre>"}]}