{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Sundials, Orbits and Analemmas","text":"<p>The <code>analemma</code> package performs sundial calculations, allowing for very general geometry that covers all common types of dial. Highlights include</p> <ul> <li>exact parametric expressions for the analemma on any type of sundial</li> <li>orbits and the equation of time for any planet</li> <li>a plotting module to draw the analemma</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install analemma\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<pre><code>import matplotlib.pyplot as plt\nfrom analemma import orbit, plot as ap\n\nearth = orbit.PlanetParameters.earth()\nvertical_dial = ap.DialParameters.vertical(location='Cambridge, UK')\n\nfig, ax = plt.subplots()\nax.axis(\"equal\")\n\nap.plot_analemma(ax, earth, vertical_dial)\n</code></pre> <p>See Analemma Plots for complete examples.</p>"},{"location":"#background","title":"Background","text":"<p>The analemma is the path traced by the shadow on a sundial (or the sun in the sky) when observed at the same time each day throughout one year. The exact formulae for the analemma are derived from first principles in The Sundial Problem from a New Angle and reproduced using SymPy and GAlgebra in two Jupyter notebooks.</p> <ul> <li>Sundial Calculations works in terms of several angles describing the sundial and its planet, two of which vary with time. \\(\\sigma_t\\) measures the progress of the planet around its orbit and \\(\\psi_t\\) measures the rotation of the planet on its axis.</li> <li>The Equation of Time relates \\(\\sigma_t\\) and \\(\\psi_t\\) to time by calculating the planet's orbit.</li> </ul> <p>The results of these derivations are implemented in two modules in the <code>analemma</code> package.  </p> <ul> <li>analemma.geometry implements the results from Sundial Calculations</li> <li>analemma.orbit implements the results from The Equation of Time</li> </ul> <p>Finally, analemma.plot provides functionality for plotting the analemma which is demonstrated in Analemma Plots.</p>"},{"location":"api_reference/","title":"Analemma Package API Reference","text":""},{"location":"api_reference/#modules","title":"Modules","text":""},{"location":"api_reference/#geometry","title":"geometry","text":""},{"location":"api_reference/#orbit","title":"orbit","text":""},{"location":"api_reference/#plot","title":"plot","text":""},{"location":"api_reference/#module-geometry","title":"Module: <code>geometry</code>","text":"<p>Implementation of formulae for calculating sundial geometry</p> <p></p>"},{"location":"api_reference/#analemma.geometry.hour_angle","title":"<code>hour_angle(alpha, sigma, psi, iota_minus_theta=np.nan)</code>","text":"<p>Evaluate the inverse tangent of the sun's hour angle</p> Source code in <code>src/analemma/geometry.py</code> <pre><code>def hour_angle(alpha, sigma, psi, iota_minus_theta=np.nan):\n    \"Evaluate the inverse tangent of the sun's hour angle\"\n\n    sinXi_sin_mu, sinXi_cos_mu = hour_angle_terms(alpha, sigma, psi, iota_minus_theta)\n    return np.arctan2(sinXi_sin_mu, sinXi_cos_mu)\n</code></pre>"},{"location":"api_reference/#analemma.geometry.hour_angle_terms","title":"<code>hour_angle_terms(alpha, sigma, psi, iota_minus_theta=np.nan)</code>","text":"<p>Generalized hour angle of the sun measured as the angle between the gnomon and a sun ray</p> <p>Return the numerator and denominator in the tangent of the angle. Each contains a factor of sin(Xi) which cancels in the ratio.</p> <p>When iota_minus_theta is zero, this reduces to the common definition of hour angle</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <p>Tilt of Earth's axis of rotation from normal to the plane of its orbit</p> required <code>sigma</code> <p>Angle between Earth-Sun vector and the same at summer solstice</p> required <code>psi</code> <p>Measuring the rotation of the Earth</p> required <code>iota_minus_theta</code> <p>Angle of gnomon in the meridian plane relative to latitude</p> <code>nan</code> Source code in <code>src/analemma/geometry.py</code> <pre><code>def hour_angle_terms(alpha, sigma, psi, iota_minus_theta=np.nan):\n    \"\"\"\n    Generalized hour angle of the sun measured as the angle between the gnomon and a sun ray\n\n    Return the numerator and denominator in the tangent of the angle. Each contains a factor\n    of sin(Xi) which cancels in the ratio.\n\n    When iota_minus_theta is zero, this reduces to the common definition of hour angle\n\n    Parameters:\n        alpha: Tilt of Earth's axis of rotation from normal to the plane of its orbit\n        sigma: Angle between Earth-Sun vector and the same at summer solstice\n        psi: Measuring the rotation of the Earth\n        iota_minus_theta: Angle of gnomon in the meridian plane relative to latitude\n    \"\"\"\n\n    if np.isnan(iota_minus_theta):\n        iota_minus_theta = 0.0\n\n    sinXi_sin_mu = sin(psi) * cos(sigma) * cos(alpha) - cos(psi) * sin(sigma)\n\n    term1 = cos(psi) * cos(sigma) * cos(alpha) + sin(psi) * sin(sigma)\n    sinXi_cos_mu = term1 * cos(iota_minus_theta) - cos(sigma) * sin(alpha) * sin(\n        iota_minus_theta\n    )\n\n    return (sinXi_sin_mu, sinXi_cos_mu)\n</code></pre>"},{"location":"api_reference/#analemma.geometry.shadow_coords_xy","title":"<code>shadow_coords_xy(alpha, sigma, psi, iota, theta, i, d)</code>","text":"<p>Calculate the x and y coordinates of the tip of the shadow in the frame embedded in the dial face</p> <p>alpha, sigma, psi, iota and theta are as defined in sd_hour_angle_terms. The angles i and d define the orientation of the dial face.</p> Source code in <code>src/analemma/geometry.py</code> <pre><code>def shadow_coords_xy(alpha, sigma, psi, iota, theta, i, d):\n    \"\"\"\n    Calculate the x and y coordinates of the tip of the shadow in the frame embedded in the dial face\n\n    alpha, sigma, psi, iota and theta are as defined in sd_hour_angle_terms. The angles i and d\n    define the orientation of the dial face.\n    \"\"\"\n\n    sinXi_sin_mu, sinXi_cos_mu = hour_angle_terms(alpha, sigma, psi, iota - theta)\n\n    D_denom = shadow_denom(alpha, sigma, psi, theta, i, d)\n\n    x = (-sin(d) * sinXi_sin_mu * cos(iota) + cos(d) * sinXi_cos_mu) / D_denom\n    y = (\n        -(\n            sin(d) * cos(i) * sinXi_cos_mu\n            + sin(i) * sin(iota) * sinXi_sin_mu\n            + sinXi_sin_mu * cos(d) * cos(i) * cos(iota)\n        )\n        / D_denom\n    )\n\n    return (x, y)\n</code></pre>"},{"location":"api_reference/#analemma.geometry.shadow_denom","title":"<code>shadow_denom(alpha, sigma, psi, theta, i, d)</code>","text":"<p>The denominator in the shadow coordinate expressions</p> Source code in <code>src/analemma/geometry.py</code> <pre><code>def shadow_denom(alpha, sigma, psi, theta, i, d):\n    \"The denominator in the shadow coordinate expressions\"\n\n    sinXi_sin_mu_s, sinXi_cos_mu_s = hour_angle_terms(\n        alpha, sigma, psi\n    )  # calc with gnomon as a style\n    return (\n        sinXi_cos_mu_s * (sin(i) * cos(d) * cos(theta) - sin(theta) * cos(i))\n        - sinXi_sin_mu_s * sin(d) * sin(i)\n    ) + (sin(i) * sin(theta) * cos(d) + cos(i) * cos(theta)) * sin(alpha) * cos(sigma)\n</code></pre>"},{"location":"api_reference/#module-orbit","title":"Module: <code>orbit</code>","text":"<p>Implementation of formulae for calculating orbits</p> <p></p>"},{"location":"api_reference/#analemma.orbit.earth","title":"<code>earth = PlanetParameters.earth()</code>  <code>module-attribute</code>","text":"<p>An instance of PlanetParameters representing Earth</p>"},{"location":"api_reference/#analemma.orbit.PlanetParameters","title":"<code>PlanetParameters</code>  <code>dataclass</code>","text":"<p>Parameters defining a planet for sundial calculation purposes</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>float</code> <p>Number of mean days in a year</p> required <code>T_d</code> <code>int</code> <p>Number of seconds in a mean day</p> required <code>rho</code> <code>float</code> <p>Angle between axes of the ellipse and the equinoxes / solstices</p> required <code>alpha</code> <code>float</code> <p>Inclination of the earths axis of rotation</p> required <code>a</code> <code>float</code> <p>Length of the planet's orbit's semi-major axis</p> required <code>e</code> <code>float</code> <p>Eccentricity of the planet's orbit</p> required <p>The following attributes are calculated given the above parameters.</p> <p>Attributes:</p> Name Type Description <code>T_y</code> <code>int</code> <p>Number of seconds in a mean year</p> <code>om_y</code> <code>float</code> <p>Mean angular speed of the earth's centre of mass in its orbit</p> <code>om_d</code> <code>float</code> <p>Angular speed of a point on the earth about the earth's centre of mass</p> <code>om_sd</code> <code>float</code> <p>Angular speed of a point on an earth that revolves once per siderial day</p> <code>T_sd</code> <code>float</code> <p>Number of seconds in a siderial day</p> <code>Om</code> <code>float</code> <p>Angular speed parameter used in the spinor orbit formalism ( = om_y / 2 * a )</p> Source code in <code>src/analemma/orbit.py</code> <pre><code>@dataclass\nclass PlanetParameters:\n    \"\"\"\n    Parameters defining a planet for sundial calculation purposes\n\n    Parameters:\n        N: Number of mean days in a year\n        T_d: Number of seconds in a mean day\n        rho: Angle between axes of the ellipse and the equinoxes / solstices\n        alpha: Inclination of the earths axis of rotation\n        a: Length of the planet's orbit's semi-major axis\n        e: Eccentricity of the planet's orbit\n\n    The following attributes are calculated given the above parameters.\n\n    Attributes:\n        T_y: Number of seconds in a mean year\n        om_y: Mean angular speed of the earth's centre of mass in its orbit\n        om_d: Angular speed of a point on the earth about the earth's centre of mass\n        om_sd: Angular speed of a point on an earth that revolves once per siderial day\n        T_sd: Number of seconds in a siderial day\n        Om: Angular speed parameter used in the spinor orbit formalism ( = om_y / 2 * a )\n    \"\"\"\n\n    N: float\n    T_d: int\n    rho: float\n    alpha: float\n    a: float\n    e: float\n    T_y: int = field(init=False)\n    om_y: float = field(init=False)\n    om_d: float = field(init=False)\n    om_sd: float = field(init=False)\n    T_sd: float = field(init=False)\n    Om: float = field(init=False)\n\n    def __post_init__(self):\n        self.T_y = self.N * self.T_d\n        self.om_y = 2 * pi / self.T_y\n        self.om_d = 2 * pi / self.T_d\n        self.om_sd = (self.N + 1) / self.N * self.om_d\n        self.T_sd = self.N / (self.N + 1) * self.T_d\n        self.Om = pi / self.T_y * self.a\n\n    @classmethod\n    def earth(cls):\n        \"\"\"\n        Return a PlanetParameters instance representing Earth\n        \"\"\"\n        return PlanetParameters(\n            N=365.2422,\n            T_d=24 * 3600,\n            rho=12.25 / 180 * pi,\n            alpha=23.5 / 180 * pi,\n            a=149598000000,\n            e=0.017,\n        )\n</code></pre>"},{"location":"api_reference/#analemma.orbit.PlanetParameters.earth","title":"<code>earth()</code>  <code>classmethod</code>","text":"<p>Return a PlanetParameters instance representing Earth</p> Source code in <code>src/analemma/orbit.py</code> <pre><code>@classmethod\ndef earth(cls):\n    \"\"\"\n    Return a PlanetParameters instance representing Earth\n    \"\"\"\n    return PlanetParameters(\n        N=365.2422,\n        T_d=24 * 3600,\n        rho=12.25 / 180 * pi,\n        alpha=23.5 / 180 * pi,\n        a=149598000000,\n        e=0.017,\n    )\n</code></pre>"},{"location":"api_reference/#analemma.orbit.orbital_angle","title":"<code>orbital_angle(s, planet=earth, e=None)</code>","text":"<p>Calculate orbital angular coordinate given time parameter, phi(s)</p> Source code in <code>src/analemma/orbit.py</code> <pre><code>def orbital_angle(s, planet: PlanetParameters = earth, e=None):\n    \"\"\"\n    Calculate orbital angular coordinate given time parameter, phi(s)\n    \"\"\"\n    A, B, Om, _ = _kepler_params(planet, e)\n    tanSigY = (A**2 - B**2) * sin(2 * Om * s)\n    tanSigX = (A**2 + B**2) * cos(2 * Om * s) + 2 * A * B\n    return np.arctan2(tanSigY, tanSigX) + pi\n</code></pre>"},{"location":"api_reference/#analemma.orbit.orbital_radius","title":"<code>orbital_radius(s, planet=earth, e=None)</code>","text":"<p>Calculate orbital radial coordinate given spinor time parameter, r(s)</p> Source code in <code>src/analemma/orbit.py</code> <pre><code>def orbital_radius(s : np.array, planet: PlanetParameters = earth, e: float = None):\n    \"\"\"\n    Calculate orbital radial coordinate given spinor time parameter, r(s)\n    \"\"\"\n    A, B, Om, _ = _kepler_params(planet, e)\n    return A**2 + B**2 + 2 * A * B * cos(2 * Om * s)\n</code></pre>"},{"location":"api_reference/#analemma.orbit.orbital_time","title":"<code>orbital_time(s, planet=earth, e=None)</code>","text":"<p>Calculate orbital time given time parameter, t(s)</p> <p>Parameters:</p> Name Type Description Default <code>s</code> <code>array</code> <p>Spinor time parameter (note, called $        au$ in the paper)</p> required <code>planet</code> <code>PlanetParameters</code> <p>Planet whose orbit is being analyzed</p> <code>earth</code> <code>e</code> <code>float</code> <p>Optional override for the orbit's eccentricity</p> <code>None</code> Source code in <code>src/analemma/orbit.py</code> <pre><code>def orbital_time(s : np.array, planet: PlanetParameters = earth, e: float = None):\n    \"\"\"\n    Calculate orbital time given time parameter, t(s)\n\n    Parameters:\n        s: Spinor time parameter (note, called $\\tau$ in the paper)\n        planet: Planet whose orbit is being analyzed\n        e: Optional override for the orbit's eccentricity\n    \"\"\"\n    A, B, Om, T_y = _kepler_params(planet, e)\n    return (A**2 + B**2) * s + A * B / Om * sin(2 * Om * s) + T_y / 2\n</code></pre>"},{"location":"api_reference/#analemma.orbit.spinor_time","title":"<code>spinor_time(t, planet=earth, e=None)</code>","text":"<p>Invert t(s), the relationship of orbital time t with the parameter in the spinor treatment of the Kepler problem, s, to give s(t).</p> <p>Keep a cache of interpolants, one per eccentricity.</p> Source code in <code>src/analemma/orbit.py</code> <pre><code>def spinor_time(t : np.array, planet: PlanetParameters = earth, e : float = None):\n    \"\"\"\n    Invert t(s), the relationship of orbital time t with the parameter in the spinor\n    treatment of the Kepler problem, s, to give s(t).\n\n    Keep a cache of interpolants, one per eccentricity.\n    \"\"\"\n    if not e:\n        e = planet.e\n    k = _key(e)\n    if k not in _t_finegrained.keys():\n        _t_finegrained[k] = orbital_time(_s_finegrained, planet, e)\n    return np.interp(t, _t_finegrained[k], _s_finegrained)\n</code></pre>"},{"location":"api_reference/#module-plot","title":"Module: <code>plot</code>","text":"<p>Plot analemmas</p>"},{"location":"api_reference/#analemma.plot.DialParameters","title":"<code>DialParameters</code>  <code>dataclass</code>","text":"<p>Parameters defining a sundial</p> <p>Parameters:</p> Name Type Description Default <code>theta</code> <code>float</code> <p>\\(90^\\circ - \\theta\\) is the latitude of the sundial</p> required <code>iota</code> <code>float</code> <p>Inclination of the gnomon</p> required <code>i</code> <code>float</code> <p>Inclination of the dial face</p> required <code>d</code> <code>float</code> <p>Declination of the dial face</p> required <code>x_length</code> <code>float</code> <p>Width of the dial face in gnomon lengths</p> <code>10</code> <code>y_length</code> <code>float</code> <p>Length of the dial face in gnomon lengths</p> <code>10</code> Source code in <code>src/analemma/plot.py</code> <pre><code>@dataclass\nclass DialParameters:\n    \"\"\"\n    Parameters defining a sundial\n\n    Parameters:\n        theta: $90^\\circ - \\\\theta$ is the latitude of the sundial\n        iota: Inclination of the gnomon\n        i: Inclination of the dial face\n        d: Declination of the dial face\n        x_length: Width of the dial face in gnomon lengths\n        y_length: Length of the dial face in gnomon lengths\n    \"\"\"\n\n    theta: float\n    iota: float\n    i: float\n    d: float\n    x_length: float = 10  # gnomon has unit length\n    y_length: float = 10\n\n    def trim_coords(self, x: np.array, y: np.array):\n        \"\"\"\n        Set points falling outside the dial face to nan so they don't show up when plotted\n\n        Parameters:\n            x: x-values of a set of points in 2-d\n            y: y-values of a set of points in 2-d\n        \"\"\"\n        dial_trim = lambda vec, dial_length: np.array(\n            [coord if np.abs(coord) &lt; dial_length else np.nan for coord in vec]\n        )\n        return (dial_trim(x, self.x_length), dial_trim(y, self.y_length))\n</code></pre>"},{"location":"api_reference/#analemma.plot.DialParameters.trim_coords","title":"<code>trim_coords(x, y)</code>","text":"<p>Set points falling outside the dial face to nan so they don't show up when plotted</p> <p>Parameters:</p> Name Type Description Default <code>x</code> <code>array</code> <p>x-values of a set of points in 2-d</p> required <code>y</code> <code>array</code> <p>y-values of a set of points in 2-d</p> required Source code in <code>src/analemma/plot.py</code> <pre><code>def trim_coords(self, x: np.array, y: np.array):\n    \"\"\"\n    Set points falling outside the dial face to nan so they don't show up when plotted\n\n    Parameters:\n        x: x-values of a set of points in 2-d\n        y: y-values of a set of points in 2-d\n    \"\"\"\n    dial_trim = lambda vec, dial_length: np.array(\n        [coord if np.abs(coord) &lt; dial_length else np.nan for coord in vec]\n    )\n    return (dial_trim(x, self.x_length), dial_trim(y, self.y_length))\n</code></pre>"},{"location":"api_reference/#analemma.plot.Season","title":"<code>Season</code>","text":"<p>               Bases: <code>Enum</code></p> <p>Start in Winter because orbit time starts at perihelion</p> Source code in <code>src/analemma/plot.py</code> <pre><code>class Season(Enum):\n    \"Start in Winter because orbit time starts at perihelion\"\n    Winter = 0\n    Spring = 1\n    Summer = 2\n    Autumn = 3\n</code></pre>"},{"location":"api_reference/#analemma.plot.SunTimes","title":"<code>SunTimes</code>","text":"<p>Time of key events in the journey of the sun across the sky</p> <p>Time zero is at perihelion. Note that all such key events are defined relatiev to the dial, not the ground.</p> <p>Attributes:</p> Name Type Description <code>sunrise</code> <p>The first time in the given day that the sun ray is parallel to the dial face</p> <code>noon</code> <p>The time after sunrise and before sunset when the angle bewteen sun ray and dial face is largest</p> <code>sunset</code> <p>The second time in the given day that the sun ray is parallel to the dial face</p> <code>days_since_perihelion</code> <p>Integer defining the day</p> Source code in <code>src/analemma/plot.py</code> <pre><code>class SunTimes:\n    \"\"\"\n    Time of key events in the journey of the sun across the sky\n\n    Time zero is at perihelion. Note that all such key events are defined relatiev to the dial, not the ground.\n\n    Attributes:\n        sunrise: The first time in the given day that the sun ray is parallel to the dial face\n        noon: The time after sunrise and before sunset when the angle bewteen sun ray and dial face is largest\n        sunset: The second time in the given day that the sun ray is parallel to the dial face\n        days_since_perihelion: Integer defining the day\n    \"\"\"\n\n    def __init__(\n        self,\n        sunrise: _SunTime,\n        noon: _SunTime,\n        sunset: _SunTime,\n        days_since_perihelion: int = 0,\n    ):\n        self.sunrise = _SunTime(sunrise, days_since_perihelion)\n        self.noon = _SunTime(noon, days_since_perihelion)\n        self.sunset = _SunTime(sunset, days_since_perihelion)\n        self.days_since_perihelion = days_since_perihelion\n\n    def sample_times_for_one_day(self, res : int = 1000):\n        \"\"\"\n        Generate an array of times suitable for sampling the progress of the sun across the sky\n        \"\"\"\n        # time zero is at perihelion close to noon so start 12 hours back to capture sun rise and set in order\n        raw_times = np.linspace(\n            (self.days_since_perihelion - 0.5) * 24 * 3600,\n            (self.days_since_perihelion + 0.5) * 24 * 3600,\n            res,\n        )\n        return np.array(\n            [_SunTime(raw_time, self.days_since_perihelion) for raw_time in raw_times]\n        )\n\n    def __str__(self):\n        return f\"sunrise: {self.sunrise.hours_from_midnight}, noon: {self.noon.hours_from_midnight}, sunset: {self.sunset.hours_from_midnight}\"\n</code></pre>"},{"location":"api_reference/#analemma.plot.SunTimes.sample_times_for_one_day","title":"<code>sample_times_for_one_day(res=1000)</code>","text":"<p>Generate an array of times suitable for sampling the progress of the sun across the sky</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def sample_times_for_one_day(self, res : int = 1000):\n    \"\"\"\n    Generate an array of times suitable for sampling the progress of the sun across the sky\n    \"\"\"\n    # time zero is at perihelion close to noon so start 12 hours back to capture sun rise and set in order\n    raw_times = np.linspace(\n        (self.days_since_perihelion - 0.5) * 24 * 3600,\n        (self.days_since_perihelion + 0.5) * 24 * 3600,\n        res,\n    )\n    return np.array(\n        [_SunTime(raw_time, self.days_since_perihelion) for raw_time in raw_times]\n    )\n</code></pre>"},{"location":"api_reference/#analemma.plot.annotate_analemma_with_hour","title":"<code>annotate_analemma_with_hour(ax, hour_offset, planet, dial)</code>","text":"<p>For the given hour, annotate with the time</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def annotate_analemma_with_hour(\n    ax, hour_offset: int, planet: orbit.PlanetParameters, dial: DialParameters\n):\n    \"\"\"\n    For the given hour, annotate with the time\n    \"\"\"\n    if hour_offset % 3 == 0:\n        points = _analemma_label_coordinates(hour_offset, planet, dial)\n        if points:\n            p, ptext = points\n            return ax.annotate(\n                hour_offset_to_oclock(hour_offset),\n                xy=p,\n                xytext=ptext,\n                arrowprops={\"arrowstyle\": \"-\"},\n                horizontalalignment=\"center\",\n                fontsize=\"small\",\n            )\n    return None\n</code></pre>"},{"location":"api_reference/#analemma.plot.find_daytime_offsets","title":"<code>find_daytime_offsets(planet, dial)</code>","text":"<p>Find the range of hours for which shadows are cast on the given dial</p> <p>The hours are returned as integer offsets from noon</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def find_daytime_offsets(planet: orbit.PlanetParameters, dial: DialParameters):\n    \"\"\"\n    Find the range of hours for which shadows are cast on the given dial\n\n    The hours are returned as integer offsets from noon\n    \"\"\"\n\n    tol = 0.01\n    daytime_offsets = []\n    for hour_offset in np.arange(-12, 12):\n        _, sines = sunray_dialface_angle_over_one_year(planet, dial, hour_offset)\n        if np.any(sines &gt; tol):\n            daytime_offsets.append(hour_offset)\n    return daytime_offsets\n</code></pre>"},{"location":"api_reference/#analemma.plot.find_sun_rise_noon_set_relative_to_dial_face","title":"<code>find_sun_rise_noon_set_relative_to_dial_face(days_since_perihelion, planet, dial)</code>","text":"<p>Find sunrise, noon and sunset (relative to the dial face)</p> <p>Note these because times are all relative to the dial face they do not match the common notions except for an analematic dial</p> <p>Parameters:</p> Name Type Description Default <code>days_since_perihelion</code> <code>int</code> <p>Integer defining the day</p> required <code>planet</code> <code>PlanetParameters</code> <p>Parameters of the planet</p> required <code>dial</code> <code>DialParameters</code> <p>Parameters of the sundial</p> required Source code in <code>src/analemma/plot.py</code> <pre><code>def find_sun_rise_noon_set_relative_to_dial_face(\n    days_since_perihelion: int, planet: orbit.PlanetParameters, dial: DialParameters\n) -&gt; SunTimes:\n    \"\"\"\n    Find sunrise, noon and sunset (relative to the dial face)\n\n    Note these because times are all relative to the dial face they do not match the common notions except for an analematic dial\n\n    Parameters:\n        days_since_perihelion: Integer defining the day\n        planet: Parameters of the planet\n        dial: Parameters of the sundial\n    \"\"\"\n\n    # time when sunray meets dial face at pi/2 (90 degrees):\n    t_noon_guess = (days_since_perihelion * 24) * 3600\n    t_noon_result = sci_opt.minimize(\n        lambda t: -sin_sunray_dialface_angle(t, planet, dial),\n        x0=t_noon_guess,\n        method=\"L-BFGS-B\",\n        tol=1.0e-8,\n    )\n    if not t_noon_result.success:\n        raise Exception(\n            f\"Unable to find noon with days_since_perihelion = {days_since_perihelion} and initial guess of {t_noon_guess}. Optimization result: {t_noon_result}\"\n        )\n\n    t_noon = t_noon_result.x[0]\n\n    # times when sunray is parallel to dial face\n    t_sunrise = sci_opt.brentq(\n        lambda t: sin_sunray_dialface_angle(t, planet, dial), t_noon - 12 * 3600, t_noon\n    )\n    t_sunset = sci_opt.brentq(\n        lambda t: sin_sunray_dialface_angle(t, planet, dial), t_noon, t_noon + 12 * 3600\n    )\n\n    return SunTimes(t_sunrise, t_noon, t_sunset, days_since_perihelion)\n</code></pre>"},{"location":"api_reference/#analemma.plot.hour_offset_to_oclock","title":"<code>hour_offset_to_oclock(hour_offset)</code>","text":"<p>Render an integer hour offset (eg +2) as the corresponding time (eg '2pm')</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def hour_offset_to_oclock(hour_offset: int):\n    \"\"\"\n    Render an integer hour offset (eg +2) as the corresponding time (eg '2pm')\n    \"\"\"\n    if hour_offset == 0:\n        return \"12pm\"\n    elif hour_offset == -12:\n        return \"12am\"\n    elif hour_offset &gt; 0:\n        return f\"{hour_offset}pm\"\n    elif hour_offset &lt; 0:\n        return f\"{12+hour_offset}am\"\n    else:\n        raise Exception(f\"hour_offset {hour_offset} doesn't seem to be a number\")\n</code></pre>"},{"location":"api_reference/#analemma.plot.orbit_date_to_day","title":"<code>orbit_date_to_day(the_date, year=2024)</code>","text":"<p>Convert from the date to the number of days since perihelion</p> <p>Note that this varies from year to year and this implementation is only exact for 2024</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def orbit_date_to_day(the_date: datetime.date, year=2024) -&gt; int:\n    \"\"\"\n    Convert from the date to the number of days since perihelion\n\n    Note that this varies from year to year and this implementation is only exact for 2024\n    \"\"\"\n    perihelion_date = datetime.date.fromisoformat(\n        f\"{year}-01-03\"\n    )  # approximately true for other years\n    return (the_date - perihelion_date).days\n</code></pre>"},{"location":"api_reference/#analemma.plot.orbit_day_to_date","title":"<code>orbit_day_to_date(orbit_day, year=2024)</code>","text":"<p>Convert from the number of days since perihelion to the date</p> <p>Note that this varies from year to year and this implementation is only exact for 2024</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def orbit_day_to_date(orbit_day: int, year=2024) -&gt; datetime.date:\n    \"\"\"\n    Convert from the number of days since perihelion to the date\n\n    Note that this varies from year to year and this implementation is only exact for 2024\n    \"\"\"\n    perihelion_date = datetime.date.fromisoformat(\n        f\"{year}-01-03\"\n    )  # approximately true for other years\n    return perihelion_date + datetime.timedelta(days=int(orbit_day))\n</code></pre>"},{"location":"api_reference/#analemma.plot.plot_analemma_season_segment","title":"<code>plot_analemma_season_segment(ax, season, hour_offset, planet, dial, **kwargs)</code>","text":"<p>Plot the analemma segment for the given season</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def plot_analemma_season_segment(\n    ax,\n    season: Season,\n    hour_offset: int,\n    planet: orbit.PlanetParameters,\n    dial: DialParameters,\n    **kwargs,\n):\n    \"Plot the analemma segment for the given season\"\n\n    times = _analemma_plot_sampling_times(season, hour_offset, planet, dial)\n    return _plot_analemma_segment(\n        ax,\n        times,\n        planet,\n        dial,\n        _season_format_strings[season.value],\n        label=\"\",\n        **kwargs,\n    )\n</code></pre>"},{"location":"api_reference/#analemma.plot.plot_special_sun_path","title":"<code>plot_special_sun_path(ax, season, planet, dial, **kwargs)</code>","text":"<p>Plot the path of the sun across the dial on the equinox or solstice in the given season</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def plot_special_sun_path(\n    ax, season: Season, planet: orbit.PlanetParameters, dial: DialParameters, **kwargs\n):\n    \"\"\"\n    Plot the path of the sun across the dial on the equinox or solstice in the given season\n    \"\"\"\n\n    orbit_day = orbit_date_to_day(_equinox_or_solstice_info[season.value].date)\n    sun_times = find_sun_rise_noon_set_relative_to_dial_face(orbit_day, planet, dial)\n\n    buffer_seconds = 0.1 * 3600\n    start_seconds = sun_times.sunrise.absolute_seconds + buffer_seconds\n    finish_seconds = sun_times.sunset.absolute_seconds - buffer_seconds\n\n    times = np.linspace(start_seconds, finish_seconds, 1000)\n    psis = _psi(times, planet)\n\n    sigma = _equinox_or_solstice_info[season.value].sigma\n    x_raw, y_raw = geometry.shadow_coords_xy(\n        planet.alpha, sigma, psis, dial.iota, dial.theta, dial.i, dial.d\n    )\n\n    x, y = dial.trim_coords(x_raw, y_raw)\n\n    # see comment in _calc_analemma_points\n    xx = y\n    yy = -x\n\n    return ax.plot(\n        xx, yy, _season_format_strings[season.value], label=season.name, **kwargs\n    )\n</code></pre>"},{"location":"api_reference/#analemma.plot.sin_sunray_dialface_angle","title":"<code>sin_sunray_dialface_angle(t, planet, dial)</code>","text":"<p>Sine of the angle between the sun ray and the dial face</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def sin_sunray_dialface_angle(t : np.array, planet: orbit.PlanetParameters, dial: DialParameters):\n    \"\"\"\n    Sine of the angle between the sun ray and the dial face\n    \"\"\"\n\n    alpha = planet.alpha\n    theta = dial.theta\n    i = dial.i\n    d = dial.d\n\n    psi = _psi(t, planet)\n    sigma = _sigma(t, planet)\n\n    # -(G^(-s))|I where G is the dial face, s the sunray and I the pseudoscalar\n    val = (\n        -sin(alpha) * sin(i) * sin(theta) * cos(d) * cos(sigma)\n        - sin(alpha) * cos(i) * cos(sigma) * cos(theta)\n        + sin(d) * sin(i) * sin(psi) * cos(alpha) * cos(sigma)\n        - sin(d) * sin(i) * sin(sigma) * cos(psi)\n        - sin(i) * sin(psi) * sin(sigma) * cos(d) * cos(theta)\n        - sin(i) * cos(alpha) * cos(d) * cos(psi) * cos(sigma) * cos(theta)\n        + sin(psi) * sin(sigma) * sin(theta) * cos(i)\n        + sin(theta) * cos(alpha) * cos(i) * cos(psi) * cos(sigma)\n    )\n    return -val  # because (-s)\n</code></pre>"},{"location":"api_reference/#analemma.plot.sunray_dialface_angle_over_one_year","title":"<code>sunray_dialface_angle_over_one_year(planet, dial, hour_offset=0)</code>","text":"<p>Calculate daily the time since perihelion in seconds and the corresponding sin(sunray-dialface angle)</p> Source code in <code>src/analemma/plot.py</code> <pre><code>def sunray_dialface_angle_over_one_year(\n    planet: orbit.PlanetParameters, dial: DialParameters, hour_offset=0\n):\n    \"\"\"\n    Calculate daily the time since perihelion in seconds and the corresponding sin(sunray-dialface angle)\n    \"\"\"\n    times = planet.T_d * np.arange(0, 365)\n    times += hour_offset * 3600\n    sines = np.array(sin_sunray_dialface_angle(times, planet, dial))\n    return (times, sines)\n</code></pre>"},{"location":"equation_of_time/","title":"The Equation of Time","text":"<pre><code>import dataclasses, math\nimport numpy as np\nfrom numpy import sin, cos\nimport matplotlib.pyplot as plt\n</code></pre> <p>The \"Equation of Time\" refers to the observed difference between a given time, say noon UTC, and the time at which the sun is directly overhead. This phenomenon is due to two effects; the tilt of the Earth's axis \\(\\alpha\\), and the elliptical nature of the Earth's orbit around the sun owing to a non-zero eccentricity \\(e\\):</p> <p>.</p> <p>We will need several constants relating to the Earth's orbit</p> <pre><code>pi = math.pi\n\n@dataclasses.dataclass\nclass EotConstants:\n    N : float = 365.2422 # number of mean days in a year\n    T_d : int = 24 * 3600 # number of seconds in a mean day\n    T_y : int = N * T_d # number of seconds in a mean year    \n    om_y : float = 2*pi / T_y # mean angular speed of the earth's centre of mass in its orbit\n    om_d : float = 2*pi / T_d # angular speed of a point on the earth about the earth's centre of mass\n    om_sd : float = (N+1) / N * om_d # angular speed of a point on an earth that revolves once per siderial day\n    T_sd : float = N / (N+1) * T_d # number of seconds in a siderial day\n    rho : float = 12.25 / 180 * pi # angle between axes of the ellipse and the equinoxes / solstices\n    alpha : float = 23.5 / 180 * pi # inclination of the earths axis of rotation\n    a : float = 149598000000 # earth-sun orbit semi-major axes length in metres\n    e : float = 0.017 # eccentricity of the earth-sun orbit\n    Om : float = pi / T_y * a # angular speed parameter used in spinor orbit formalism ( = om_y / 2 * a )\n\nC = EotConstants()\n\n# start time at perihelion, sample once per mean day\nt_integers = np.arange(int(C.N))\nt = C.T_d * t_integers\n\nprint(f\"t has {len(t)} times from {t[0]} to {t[-1]} seconds\")\n</code></pre> <pre><code>t has 365 times from 0 to 31449600 seconds\n</code></pre> <p>So, the variable \\(t\\) is our timeline, sampling one year at (mean) daily intervals.</p> <p>The hour angle formula derived in the sundial calculation has inputs:</p> <ul> <li>\\(\\sigma(t)\\) - the progress of Earth on its orbit</li> <li>\\(\\psi(t)\\) - the spin of the Earth</li> <li>\\(\\alpha\\) - the tilt of the Earth's axis</li> </ul> <p>Start by modeling \\(\\sigma(t)\\) and \\(\\psi(t)\\) linearly to isolate the effect of \\(\\alpha\\).</p> <pre><code>def hour_angle(alpha, sigma, psi, iota_minus_theta = np.nan):\n\n    if np.isnan(iota_minus_theta):\n        iota_minus_theta = 0.0    \n\n    tanMuY = sin(psi)*cos(sigma)*cos(alpha) - cos(psi)*sin(sigma)\n    term1  = cos(psi)*cos(sigma)*cos(alpha) + sin(psi)*sin(sigma)\n    tanMuX = term1*cos(iota_minus_theta) - cos(sigma)*sin(alpha)*sin(iota_minus_theta)\n    return np.arctan2( tanMuY, tanMuX )\n\n# psi increases linearly with time, one complete revolution after one siderial day,\n# and an offset of rho\npsi = np.mod(C.rho + C.om_sd*t, 2*pi)\n# Increase sigma at constant rate of 2*pi per solar year to isolate effect of alpha.\n# Orbit (phi) starts at perihelion which is C.rho degrees past -e_1\n# and sigma starts at +e_1 which is pi radians away from -e_1, hence pi + C.rho.\nsigma = np.mod(pi + C.rho + C.om_y*t, 2*pi)\n\n# calc hour angle\nmu = np.mod(hour_angle(C.alpha, sigma, psi), 2*pi)\nmu0 = np.mod(hour_angle(0, sigma, psi), 2*pi)\nmu45 = np.mod(hour_angle(45 / 180 * pi, sigma, psi), 2*pi)\n\ndef s2d(seconds):\n    \"Convert seconds to days\"\n    return seconds / 24 / 3600\n\ndef r2d(radians):\n    \"Convert radians to degrees\"\n    return radians / pi * 180\n\nfig, ax = plt.subplots()\nax.plot( s2d(t), r2d(pi - mu0), label=r\"$\\alpha = 0^\\circ$\" )\nax.plot( s2d(t), r2d(pi - mu), label=r\"$\\alpha = 23.5^\\circ$ (Earth)\" )\nax.plot( s2d(t), r2d(pi - mu45), label=r\"$\\alpha = 45^\\circ$\" )\nax.legend()\nax.grid()\nax.set_xlabel( 'Number of days since perihelion' )\nax.set_ylabel( 'Solar hour angle $\\mu$ (degrees)' )\nax.set_title( r'Effect of planetary axis tilt ($\\alpha$) on hour angle' )\n</code></pre> <pre><code>Text(0.5, 1.0, 'Effect of planetary axis tilt ($\\\\alpha$) on hour angle')\n</code></pre> <p></p>"},{"location":"equation_of_time/#orbital-time","title":"Orbital Time","text":"<p>Now to introduce Keplerian dynamics and change the model for \\(\\sigma(t)\\). The orbit \\((r(t), \\phi(t))\\) can be parameterized as \\(r(s)\\), \\(\\phi(s)\\) and \\(t(s)\\) as derived in the appendix of my paper, just quoted here. Starting with \\(t(s)\\):</p> <pre><code>def _kepler_params(C = EotConstants(), e = None):\n    a = C.a\n    if not e:\n        e = C.e\n    b = a*math.sqrt(1-e**2) # semi-minor axis\n    A = math.sqrt((a+b)/2)\n    B = math.sqrt((a-b)/2)\n    return A, B, C.Om, C.T_y\n\ndef orbital_time( s, C = EotConstants(), e = None ):\n    \"Calculate orbital time given time parameter, t(s)\"\n    A, B, Om, T_y = _kepler_params(C, e)\n    return (A**2+B**2)*s + A*B/Om*sin(2*Om*s) + T_y/2\n\ns_vector = np.linspace(-pi/C.Om/2, pi/C.Om/2, 365)\nt_vector = orbital_time(s_vector)\nt_vector_eccentric = orbital_time(s_vector, C, e=0.5)\nt_vector_very_eccentric = orbital_time(s_vector, C, e=0.99)\n\nfig, ax = plt.subplots()\nax.plot( s_vector, s2d(t_vector), label=f\"e = {C.e} (Earth)\" )\nax.plot( s_vector, s2d(t_vector_eccentric), label=f\"e = {0.5}\" )\nax.plot( s_vector, s2d(t_vector_very_eccentric), label=f\"e = {0.99}\" )\nax.legend()\nax.grid()\nax.set_xlabel( 'Spinor time parameter' )\nax.set_ylabel( 'Absolute time t in days' )\nax.set_title(\"Orbital Time\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Orbital Time')\n</code></pre> <p></p>"},{"location":"equation_of_time/#invert-the-time-relation","title":"Invert the time relation","text":"<p>In order to calcuate \\(r(t) = r(t(s))\\) and \\(\\phi(t) = \\phi(t(s))\\), we need invert the functional form for \\(t(s)\\). Given its monotonic nature, we can use interpolation:</p> <pre><code># get at least 4 SF of accuracy in the inversion with 10k points\ns_finegrained = np.linspace(-pi/C.Om/2, pi/C.Om/2, 10_000)\n\n# Cache interpolation points, one per eccentricity, using first 4 digits\ndef _key(e):\n    return int(10_000*e)\n\nt_finegrained = {_key(C.e):orbital_time(s_finegrained)}\n\ndef spinor_time(t, C = EotConstants(), e=None):\n    if not e:\n        e = C.e\n    k = _key(e)\n    if k not in t_finegrained.keys():\n        t_finegrained[k] = orbital_time(s_finegrained, C, e)\n    return np.interp(t, t_finegrained[k], s_finegrained)\n\nassert len(t_finegrained) == 1\nt_eval = 50 * 24*3600 # evaluate 50 days into orbit\ns1 = spinor_time(t_eval)\nassert math.isclose(t_eval, orbital_time(s1), rel_tol=1e-9) # round trip\nassert len(t_finegrained) == 1 # hit the existing cache of t values\ne99 = 0.99 # very eccentric\ns2 = spinor_time(t_eval, C, e99)\nassert len(t_finegrained) == 2 # create new cache of t values\nassert not math.isclose(s1, s2, abs_tol=1e-5) # different e means different s\nassert math.isclose(t_eval, orbital_time(s2, C, e99), rel_tol=1e-7) # round trip\n</code></pre>"},{"location":"equation_of_time/#orbital-radius","title":"Orbital Radius","text":"<p>Although not necessary to calculate the equation of time, for completeness let's look at the radial coordinate (from the orbit's focus) over time also:</p> <pre><code>def orbital_radius(s, C = EotConstants(), e = None):\n    \"Calculate orbital radial coordinate given spinor time parameter, r(s)\"\n    A, B, Om, _ = _kepler_params(C, e)\n    return A**2 + B**2 + 2*A*B*cos(2*Om*s)\n\ne_venus = 0.0068\ne_mars = 0.0934\n\nt_days = t/3600/24\n\norb_rad_ratio_venus = orbital_radius(spinor_time(t, C, e_venus), C, e_venus)/C.a\norb_rad_ratio_earth = orbital_radius(spinor_time(t))/C.a\norb_rad_ratio_mars = orbital_radius(spinor_time(t, C, e_mars), C, e_mars)/C.a\n\nfig, ax = plt.subplots()\nax.plot( t_days, orb_rad_ratio_venus, label=f\"e = {e_venus} (Venus)\" )\nax.plot( t_days, orb_rad_ratio_earth, label=f\"e = {C.e} (Earth)\" )\nax.plot( t_days, orb_rad_ratio_mars, label=f\"e = {e_mars} (Mars)\" )\nax.legend()\nax.grid()\nax.set_xlabel(\"Orbital time (days)\")\nax.set_ylabel(\"Orbital radius $r$ / semi-major axis $a$ ($r/a$)\")\nax.set_title(\"Orbital Radius\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Orbital Radius')\n</code></pre> <p></p>"},{"location":"equation_of_time/#orbital-angle","title":"Orbital Angle","text":"<p>The angle of the orbit (again in radial coordinates with origin at the orbit's focus) varies non-linearly with time for an elliptical orbit, and this provides the second component of the Equation of Time.</p> <pre><code>def orbital_angle(s, C = EotConstants(), e = None):\n    \"Calculate orbital angular coordinate given time parameter, phi(s)\"\n    A, B, Om, _ = _kepler_params(C, e)\n    tanSigY = ( (A**2-B**2)*sin(2*Om*s) )\n    tanSigX = ( (A**2+B**2)*cos(2*Om*s) + 2*A*B )\n    return np.arctan2( tanSigY, tanSigX ) + pi\n\ne_circle = 0.0\ne_mercury = 0.2056\ne_halleys_comet = 0.9671\n\nt_days = t_vector/3600/24\norb_angle_circle = orbital_angle(spinor_time(t, C, e_circle), C, e_circle)\norb_angle_earth = orbital_angle(spinor_time(t))\norb_angle_mercury = orbital_angle(spinor_time(t, C, e_mercury), C, e_mercury)\norb_angle_halleys_comet = orbital_angle(spinor_time(t, C, e_halleys_comet), C, e_halleys_comet)\n\nfig, ax = plt.subplots()\nax.plot( t_days, r2d(orb_angle_circle), \"+\", label=f\"e = {e_circle} (Perfect Circle)\" )\nax.plot( t_days, r2d(orb_angle_earth), label=f\"e = {C.e} (Earth)\" )\nax.plot( t_days, r2d(orb_angle_mercury), label=f\"e = {e_mercury} (Mercury)\" )\nax.plot( t_days, r2d(orb_angle_halleys_comet), label=f\"e = {e_halleys_comet} (Halley's Comet)\" )\nax.legend()\nax.grid()\nax.set_xlabel(\"Orbital time (days)\")\nax.set_ylabel(\"Orbital angle\")\nax.set_title(\"Orbital Angle\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Orbital Angle')\n</code></pre> <p></p>"},{"location":"equation_of_time/#orbital-path","title":"Orbital Path","text":"<p>Again, not necessary for the Equation of Time, but for completeness, let's look at the Earth's orbital path:</p> <pre><code>def orbit_path(s, C = EotConstants(), e = None):\n    return (orbital_radius(spinor_time(t, C, e), C, e)*cos(orbital_angle(spinor_time(t, C, e), C, e)) / C.a,\n            orbital_radius(spinor_time(t, C, e), C, e)*sin(orbital_angle(spinor_time(t, C, e), C, e)) / C.a) \n\npath_earth = orbit_path(spinor_time(t))\npath_circle = orbit_path(spinor_time(t, C, e_circle), C, e_circle)\n\nfig, ax = plt.subplots()\nax.plot(*path_circle, \"+\", label=\"Perfect Circle\")\nax.plot(*path_earth, label=\"Earth\")\nax.grid()\nax.set_aspect(\"equal\", \"box\")\nax.legend()\nax.set_xlabel(\"x/a\")\nax.set_ylabel(\"y/a\")\nax.set_title(\"Orbital Path (distance in units of semi-major axis, $a$)\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Orbital Path (distance in units of semi-major axis, $a$)')\n</code></pre> <p></p>"},{"location":"equation_of_time/#effect-of-orbital-eccentricity","title":"Effect of Orbital Eccentricity","text":"<p>We can isolate the effect of a Keplerian orbit by setting the Earth's axis tilt angle \\(\\alpha\\) to zero:</p> <pre><code># now account for orbit in rate of increase of sigma\nsigma = np.mod(pi + C.rho + orbital_angle(spinor_time(t)), 2*pi)\n\nmu = np.mod(hour_angle(0.0, sigma, psi), 2*pi)\n\nfig, ax = plt.subplots()\nax.plot(s2d(t), r2d(mu))\nax.grid()\nax.set_xlabel(\"Days since perihelion\")\nax.set_ylabel(\"Hour angle ($\\mu$)\")\nax.set_title(\"Effect of orbital eccentricity ($e$) on hour angle\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Effect of orbital eccentricity ($e$) on hour angle')\n</code></pre> <p></p>"},{"location":"equation_of_time/#equation-of-time","title":"Equation of Time","text":"<p>Finally, we can combine both effect and plot the Equation of Time for Earth.</p> <pre><code>sigma_alpha_only = np.mod(pi + C.rho + C.om_y*t, 2*pi)\nmu_alpha_only = np.mod(hour_angle(C.alpha, sigma_alpha_only, psi), 2*pi)\n\nsigma_eot = np.mod(pi + C.rho + orbital_angle(spinor_time(t)), 2*pi)\nmu_e_only = np.mod(hour_angle(0.0, sigma_eot, psi), 2*pi)\n\nmu_eot = np.mod(hour_angle(C.alpha, sigma_eot, psi), 2*pi)\n\nfig, ax = plt.subplots()\n# 1 degree is 4 minutes if 360 degrees is 24 hours\nax.plot(s2d(t), 4*r2d(pi - mu_alpha_only), label=\"Effective of Earth's axis tilt\")\nax.plot(s2d(t), 4*r2d(pi - mu_e_only), label=\"Effect of Keplerian orbit\")\nax.plot(s2d(t), 4*r2d(pi - mu_eot), label=\"Effect of both\")\nax.grid()\nax.legend()\nax.set_xlabel(\"Days since perihelion\")\nax.set_ylabel(\"Minutes\")\nax.set_title(\"The Equation of Time\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'The Equation of Time')\n</code></pre> <p></p> <p>Capture the key results from this notebook in the <code>sundial</code> module</p> <pre><code>from analemma import geometry, orbit\n\nassert orbit.earth.N == C.N\nassert orbit.earth.T_d == C.T_d\nassert orbit.earth.T_y == C.T_y\nassert orbit.earth.om_y == C.om_y\nassert orbit.earth.om_d == C.om_d\nassert orbit.earth.om_sd == C.om_sd\nassert orbit.earth.T_sd == C.T_sd\nassert orbit.earth.rho == C.rho\nassert orbit.earth.alpha == C.alpha\nassert orbit.earth.a == C.a\nassert orbit.earth.e == C.e\nassert orbit.earth.Om == C.Om\n\nassert (geometry.hour_angle(orbit.earth.alpha, sigma, psi) == hour_angle(C.alpha, sigma, psi)).all()\n\nassert (orbit.orbital_time(s_vector, C, e=0.99) == orbital_time(s_vector, C, e=0.99)).all()\n\nassert (orbit.spinor_time(t_eval, C, e99) == spinor_time(t_eval, C, e99)).all()\n\nassert (orbit.orbital_radius(spinor_time(t, C, e_mars), C, e=e_mars)\n        == orbital_radius(spinor_time(t, C, e_mars), C, e=e_mars)).all()\n\nassert (orbit.orbital_angle(spinor_time(t, C, e_halleys_comet), C, e_halleys_comet)\n        == orbital_angle(spinor_time(t, C, e_halleys_comet), C, e_halleys_comet)).all()\n</code></pre>"},{"location":"sundial/","title":"Sundial Calculations","text":"<p>This notebook accompanies my sundial paper. I originally used Maple for the calculations, but decided to reproduce them here to make the analysis more accessible, and as a way to learn SymPy and GAlgebra. I used my cheat sheet for Geometric Algebra at various points.</p> <p>Run the notebook yourself: </p> <pre><code>import sympy as sp\nfrom sympy import sin, cos, tan\nfrom sympy.abc import *\nfrom galgebra import mv\nfrom galgebra.ga import Ga\nfrom galgebra.printer import latex\nfrom IPython.display import Math\n\nsp.init_printing()\n\n# Multivector mv on its own in a cell appears fine in the notebook but when nbconverted\n# to Markdown comes out as \\begin{equation*} x \\end{equation*} instead of eg $\\displaystyle x$\n# and consequently isn't rendered in HTML after running mkdocs.\ndef display(mv):\n    return(Math(latex(mv)))\n</code></pre>"},{"location":"sundial/#setup-and-definitions","title":"Setup and Definitions","text":""},{"location":"sundial/#fixed-stars-frame","title":"Fixed Stars Frame","text":"<p>First, we define the geometric algebra of 3-space and some basis blades from the frame of the \"fixed stars\"</p> <p>.</p> <pre><code>coords = sp.symbols('1 2 3', real=True)\nG3 = Ga('e', g=[1,1,1], coords=coords)\n\n(e1, e2, e3) = G3.mv()\nI = e1^e2^e3\n</code></pre>"},{"location":"sundial/#earth-frame","title":"Earth Frame","text":"<p>Now, let the tilt of the earth's plane (axis) of rotation be \\(\\alpha\\) and measure the earth's rotation by \\(\\psi\\). Then we can define the Earth frame as follows.</p> <pre><code>def rotate(mv, angle, bivec):\n    rotor = ( cos(angle/2) - (bivec) * sin(angle/2) ).trigsimp()\n    return ( rotor * mv * rotor.rev() )\n\ne1_prime = rotate(e1, alpha, e1^e3).trigsimp()\n\nf1 = rotate(e1_prime, psi, e1_prime^e2).trigsimp().trigsimp()\nf2 = rotate(e2, psi, e1_prime^e2).trigsimp().trigsimp()\nf3 = rotate(e3, alpha, e1^e3).trigsimp().trigsimp()\n\ndef print_3frame(frame, symbol):\n    return Math(fr'''\n            \\begin{{align}}\n            {symbol}_1 &amp;= {latex(frame[0])} \\nonumber \\\\\n            {symbol}_2 &amp;= {latex(frame[1])} \\nonumber \\\\\n            {symbol}_3 &amp;= {latex(frame[2])} \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_3frame((f1,f2,f3), \"f\")\n</code></pre> \\[\\displaystyle              \\begin{align}             f_1 &amp;= \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             f_2 &amp;= - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             f_3 &amp;= - \\sin{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{3} \\nonumber             \\end{align}             \\] <p>Check that this is an orthonormal frame</p> <pre><code>result = (e1 ^ e2 ^ e3) - (f1 * f2 * f3)\n\nassert result.obj.equals(0)\ndisplay(result)\n</code></pre> \\[\\displaystyle  0 \\] <p>The equatorial plane should only depend on the tilt of the Earth's axis of spin \\(\\alpha\\), not the angle by which it has rotated relative to the fixed stars \\(\\psi\\).</p> <pre><code># would like to use mv.Fmt but it seems to give LaTeX output which doesn't render after eg jupyter nbconvert --to Markdown\ndef print_eq(lhs : str, rhs : sp.Symbol):\n    return Math(fr'''\n        \\begin{{equation}}\n            {lhs} = {latex(rhs)} \\nonumber\n        \\end{{equation}}\n        ''')\n\nprint_eq(r\"f_1 \\wedge f_2\", (f1^f2))\n</code></pre> \\[\\displaystyle          \\begin{equation}             f_1 \\wedge f_2 = \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\]"},{"location":"sundial/#surface-frame","title":"Surface Frame","text":"<p>Define an orthonormal frame embedded in the Earth's surface, with \\(n_1\\) pointing South, \\(n_2\\) pointing East and \\(n_3\\) pointing up.</p> <p>.</p> <pre><code>n1 = rotate(f1, theta, f3^f1).trigsimp().trigsimp()\nn2 = f2\n\n# n3 needs a little love\nraw_n3 = rotate(f3, theta, f3^f1).obj.trigsimp()\nsympy_n3 = sp.expand(sp.expand_trig(raw_n3)) # galgebra's Mv doesn't have expand_trig as a method\nn3 = mv.Mv(sympy_n3, ga=G3)\n\nprint_3frame((n1,n2,n3), \"n\")\n</code></pre> \\[\\displaystyle              \\begin{align}             n_1 &amp;= \\left ( \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )}\\right ) \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber \\\\             n_2 &amp;= - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} \\nonumber \\\\             n_3 &amp;= \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\theta  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber             \\end{align}             \\] <p>Check that this basis is orthonormal. Geometric product of the \\(\\{n_i\\}\\) should give the pseudoscalar \\(I = e_1 \\wedge e_2 \\wedge e_3\\)</p> <pre><code>n123 = (n1*n2*n3).trigsimp()\nassert n123.obj.equals((e1*e2*e3).obj)\ndisplay(n123)\n</code></pre> \\[\\displaystyle  \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\]"},{"location":"sundial/#orbit-rotor-and-meridian-plane","title":"Orbit Rotor and Meridian Plane","text":"<p>Earth orbit rotor \\(R_\\sigma\\), and vector parallel to rays of sunshine, \\(s\\).</p> <pre><code>s = rotate(e1, sigma, e1^e2).trigsimp()\nprint_eq(\"s\", s)\n</code></pre> \\[\\displaystyle          \\begin{equation}             s = \\cos{\\left (\\sigma  \\right )} \\boldsymbol{e}_{1} + \\sin{\\left (\\sigma  \\right )} \\boldsymbol{e}_{2} \\nonumber         \\end{equation}         \\] <p>The meridian plane, \\(M\\).</p> <pre><code>M = (n1^n3).trigsimp()\nprint_eq(\"M\", M)\n</code></pre> \\[\\displaystyle          \\begin{equation}             M = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\psi  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2} + \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{3} + \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\] <p>The noon line is the intersection of the sunshine vector \\(s\\) and the meridian plane \\(M\\), which occurs where \\(s \\wedge M\\) vanishes.</p> <pre><code>display( (s^M).trigsimp() )\n</code></pre> \\[\\displaystyle \\left ( \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\] <pre><code>coeff = (s^M).trigsimp().get_coefs(3)[0]\nsoln = sp.solve(coeff.subs(sin(psi), tan(psi)*cos(psi)), tan(psi))[0]\n\nassert soln.equals(tan(sigma)/cos(alpha))\nprint_eq( r\"\\tan(\\psi)\", soln )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\psi) = \\frac{\\tan{\\left (\\sigma  \\right )}}{\\cos{\\left (\\alpha  \\right )}} \\nonumber         \\end{equation}         \\]"},{"location":"sundial/#dial-face-and-gnomon","title":"Dial face and gnomon","text":"<p>Define an orthonormal frame \\(u_1, u_2, u_3\\) as the unevaluated version of \\(n_1, n_2, n_3\\).</p> <p>.</p> <pre><code>G3u = Ga('u', g=[1,1,1], coords=coords)\n\n(u1, u2, u3) = G3u.mv()\nU = u1^u2^u3\ndisplay(U)\n</code></pre> \\[\\displaystyle  \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3}\\] <p>Dial face expressed relative to \\(u\\) basis: \\(G_u\\).</p> <pre><code>Gu = rotate(rotate(u1^u2, i, u1^u3), d, u1^u2).trigsimp()\nprint_eq( \"G_u\", Gu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             G_u = \\cos{\\left (i \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{3} - \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Frame embedded in dial face.</p> <pre><code>m1 = rotate(rotate(u1, i, u1^u3), d, u1^u2).trigsimp()\nm2 = rotate(rotate(u2, i, u1^u3), d, u1^u2)\nm3 = rotate(rotate(u3, i, u1^u3), d, u1^u2).trigsimp()\n\nprint_3frame((m1,m2,m3), \"m\")\n</code></pre> \\[\\displaystyle              \\begin{align}             m_1 &amp;= \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\boldsymbol{u}_{1} + \\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\boldsymbol{u}_{2} + \\sin{\\left (i \\right )} \\boldsymbol{u}_{3} \\nonumber \\\\             m_2 &amp;= - \\sin{\\left (d \\right )} \\boldsymbol{u}_{1} + \\cos{\\left (d \\right )} \\boldsymbol{u}_{2} \\nonumber \\\\             m_3 &amp;= - \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\boldsymbol{u}_{1} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\boldsymbol{u}_{2} + \\cos{\\left (i \\right )} \\boldsymbol{u}_{3} \\nonumber             \\end{align}             \\] <p>The gnomon expressed relative to the \\(u\\) frame, \\(g_u\\).</p> <p>.</p> <pre><code>gu = rotate(rotate(u3, iota, u1^u3), delta, u1^u2).trigsimp()\n\n# extra manipulation to display exactly as in paper\nprint_eq(\"g_u\", sp.collect(sp.trigsimp(gu.obj), -sin(iota)))\n</code></pre> \\[\\displaystyle          \\begin{equation}             g_u = - \\sin{\\left (\\iota  \\right )} \\left(\\sin{\\left (\\delta  \\right )} \\boldsymbol{u}_{2} + \\cos{\\left (\\delta  \\right )} \\boldsymbol{u}_{1}\\right) + \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Projected onto the fixed-stars basis, the gnomon is</p> <pre><code>g = sum([ c*ni for c, ni in zip(gu.get_coefs(1),[n1, n2, n3])])\ng = g.trigsimp()\n\n# would like to use .Fmt(3) but having rendering issues\ndef print_vec(lhs, vec, symbol=\"e\", func=lambda x: x):\n    coeffs = vec.get_coefs(1)\n    return Math(fr'''\n            \\begin{{align}}\n            {lhs} &amp; = {latex(func(coeffs[0]))} {symbol}_1 \\nonumber \\\\\n            &amp; + {latex(func(coeffs[1]))} {symbol}_2 \\nonumber \\\\\n            &amp; + {latex(func(coeffs[2]))} {symbol}_3 \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_vec(\"g\", g)\n</code></pre> \\[\\displaystyle              \\begin{align}             g &amp; = - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\delta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} - \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} e_2 \\nonumber \\\\             &amp; + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} e_3 \\nonumber             \\end{align}             \\] <p>The gnomon lies in the meridian plane when the following trivector vanishes:</p> <pre><code>M_wedge_g = M^g\nassert M_wedge_g.obj.trigsimp().equals((sin(delta)*sin(iota)*e1^e2^e3).obj)\ndisplay( M_wedge_g )\n</code></pre> \\[\\displaystyle \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\boldsymbol{e}_{1}\\wedge \\boldsymbol{e}_{2}\\wedge \\boldsymbol{e}_{3}\\] <p>Will also want \\(s\\) on the \\(n\\) frame</p> <pre><code>coeffs = [sp.trigsimp((s|c).obj) for c in [n1, n2, n3]]\nsu = sum([coeff*vec for coeff, vec in zip(coeffs, [u1, u2, u3])])\nprint_vec(\"s_u\", su, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             s_u &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} u_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} u_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} u_3 \\nonumber             \\end{align}             \\]"},{"location":"sundial/#the-calculation","title":"The Calculation","text":"<p>The calculation proceeds by defining \\(S = s \\wedge g\\), the plane containing the sunshine vector and the gnomon. Its magnitude is the (negative) cosine of the angle bewteen \\(s\\) and \\(g\\). Then we can obtain a generalized solar hour angle \\(\\mu\\) as the angle between \\(S\\) and \\(M\\), given by</p> \\[\\cos(\\mu) = \\frac{-S\\cdot M}{\\sqrt{-S^2}\\sqrt{-M^2}} = \\frac{-S\\cdot M}{\\sin(\\Xi)}\\] <p>given that \\(M^2=-1\\). In anticipation of setting \\(\\delta =0\\), I will apply \\(\\delta\\) as a subscript to these quantities for now.</p> <pre><code>S_delta = s^g\n\ndef print_bivec(lhs, bivec, symbol=\"e\"):\n    coeffs = bivec.get_coefs(2)\n    return Math(fr'''\n            \\begin{{align}}\n            {lhs} &amp; = {latex(coeffs[0])} {symbol}_1 \\wedge {symbol}_2 \\nonumber \\\\\n            &amp; + {latex(coeffs[1])} {symbol}_1 \\wedge {symbol}_3 \\nonumber \\\\\n            &amp; + {latex(coeffs[2])} {symbol}_2 \\wedge {symbol}_3 \\nonumber\n            \\end{{align}}\n            ''')\n\nprint_bivec(\"S_\\delta\", S_delta)\n</code></pre> \\[\\displaystyle              \\begin{align}             S_\\delta &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\delta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} - \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\wedge e_2 \\nonumber \\\\             &amp; + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} e_1 \\wedge e_3 \\nonumber \\\\             &amp; + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} e_2 \\wedge e_3 \\nonumber             \\end{align}             \\] <p>Angle \\(\\Xi\\) between sun ray and gnomon:</p> <pre><code>cosXi_delta = sp.trigsimp((s|g).obj)\nprint_eq(r\"\\cos(\\Xi_\\delta)\", cosXi_delta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\Xi_\\delta) = \\left(- \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} - \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\sigma  \\right )} + \\left(- \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\delta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\delta  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\cos{\\left (\\sigma  \\right )} \\nonumber         \\end{equation}         \\] <p>Hour angle \\(\\mu\\):</p> <pre><code>sinXi_cos_mu_delta = sp.trigsimp(-(S_delta|M).obj)\n\nprint_eq( r\"\\sin(\\Xi_\\delta) \\cos(\\mu_\\delta)\", sinXi_cos_mu_delta )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi_\\delta) \\cos(\\mu_\\delta) = - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\delta  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\delta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} \\nonumber         \\end{equation}         \\]"},{"location":"sundial/#a-simplifying-assumption","title":"A Simplifying Assumption","text":"<p>While \\(\\sin(\\Xi)\\cos(\\mu)\\) is available in closed form, I have not been able to factorize \\(\\sin(\\Xi)\\sin(\\mu) = \\sqrt{1-\\sin^2(\\Xi)\\cos^2(\\mu)}\\). While we can always proceed numerically, there is a nice factorization available in the case where the gnomon's declination angle \\(\\delta\\) is zero, so that it remains in the \\(n_1 \\wedge n_3\\) plane, so I will work in that case from here.</p> <pre><code>gu_delta = gu\ngu = gu.subs(delta, 0)\nprint_eq( \"g_u\", gu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             g_u = - \\sin{\\left (\\iota  \\right )} \\boldsymbol{u}_{1} + \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <pre><code>g_delta = g\ng = g.subs(delta, 0)\nprint_eq( \"g\", g)\n</code></pre> \\[\\displaystyle          \\begin{equation}             g = \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right ) \\boldsymbol{e}_{3} \\nonumber         \\end{equation}         \\] <p><code>g.obj</code> trails behind by one trigsimp</p> <pre><code>display( g.obj )\n</code></pre> \\[\\displaystyle \\left(- \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\boldsymbol{e}_{2} + \\left(- \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\boldsymbol{e}_{1} + \\left(- \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\boldsymbol{e}_{3}\\] <p>Hack: ensure a healthy <code>g.obj</code> by reforming \\(g\\) from the result of applying <code>sympy.trigsimp</code> to each component individually</p> <pre><code>g = sum([sp.trigsimp(coef)*vec for coef, vec in zip(g.get_coefs(1), G3.mv())])\ndisplay( g )\n</code></pre> \\[\\displaystyle \\left ( - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right ) \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} + \\left ( - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right ) \\boldsymbol{e}_{3}\\] <pre><code># eyeball check:\ndisplay( g.obj )\n</code></pre> \\[\\displaystyle - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{3} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{1} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{2} - \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\boldsymbol{e}_{1} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\boldsymbol{e}_{3}\\]"},{"location":"sundial/#the-shadow-plane","title":"The Shadow Plane","text":"<p>Setting \\(\\delta = 0\\) in the shadow plane \\(S = s \\wedge g\\) (the plane containing the sunshine vector and the gnomon) gives a more manageable expression.</p> <pre><code>S = s^g\n\nprint_bivec(\"S\", S)\n</code></pre> \\[\\displaystyle              \\begin{align}             S &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\wedge e_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_1 \\wedge e_3 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_2 \\wedge e_3 \\nonumber             \\end{align}             \\] <p>Appl the \\(\\delta=0\\) assumption to the cosine of the angle \\(\\Xi\\) between sun ray and gnomon:</p> <pre><code>cosXi = sp.trigsimp((s|g).obj)\nprint_eq(r\"\\cos(\\Xi)\", cosXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\Xi) = - \\left(\\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} + \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\nonumber         \\end{equation}         \\] <p>Check \\(S^2 = (s\\wedge g)^2 = (s\\cdot g)^2 - s^2 g^2\\) where \\(s^2 = g^2 = 1\\). </p> <pre><code>sg_squared = (s|g)*(s|g)\nS_norm_check = (S|S) - ( sg_squared - 1 )\nassert S_norm_check.obj.equals(0)\ndisplay( S_norm_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>The magnitude of \\(S\\) is given by \\(\\sqrt{-S^2} = \\sqrt{1 - (s\\cdot g)^2} = \\sqrt{1 - \\cos^2(\\Xi}) = \\sin^2(\\Xi)\\):</p> <pre><code>sinXi = sp.sqrt( 1 - ((cos(alpha)*cos(sigma)*cos(psi) + sin(sigma)*sin(psi))*sin(iota-theta) + sin(alpha)*cos(sigma)*cos(iota-theta))**2 )\nprint_eq(\"\\sin(\\Xi)\", sinXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) = \\sqrt{1 - \\left(\\left(\\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}\\right) \\sin{\\left (\\iota  - \\theta  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right)^{2}} \\nonumber         \\end{equation}         \\] <pre><code># check\nsg_check = sinXi**2 - ( 1 - sg_squared )\nassert sg_check.obj.equals(0)\ndisplay( sg_check )\n</code></pre> \\[\\displaystyle  0 \\]"},{"location":"sundial/#the-hour-angle","title":"The Hour Angle","text":"<p>We can now calculate the generalized solar hour angle \\(\\mu\\) (the angle between \\(S\\) and \\(M\\)), given by \\(\\cos(\\mu) = \\frac{-S\\cdot M}{\\sin(\\Xi)}\\) and also obtain a nice expression in closed form for \\(\\sin(\\mu)\\).</p> <pre><code>sinXi_cos_mu = sp.trigsimp(-(S|M).obj)\n\nprint_eq( r\"\\sin(\\Xi) \\cos(\\mu)\", sinXi_cos_mu )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) \\cos(\\mu) = - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\nonumber         \\end{equation}         \\] <p>From \\(\\sin^2\\mu + \\cos^2\\mu = 1\\) (by hand), we have:</p> <pre><code>sinXi_sin_mu = cos(alpha)*sin(psi)*cos(sigma) - cos(psi)*sin(sigma)\nprint_eq(\"\\sin(\\Xi) \\sin(\\mu)\", sinXi_sin_mu)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) \\sin(\\mu) = \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} \\nonumber         \\end{equation}         \\] <p>Check that \\(\\sin^2(\\Xi)\\sin^2(\\mu) + \\sin^2(\\Xi)\\cos^2(\\mu) = \\sin^2(\\Xi)\\)</p> <pre><code>Xi_check = sp.trigsimp( sp.expand(sinXi_sin_mu**2) + sp.expand(sinXi_cos_mu**2) - sp.expand(sinXi**2) )\nassert Xi_check.equals(0)\ndisplay( Xi_check )\n</code></pre> \\[\\displaystyle 0\\] <p>The ratio gives \\(\\tan(\\mu)\\) as in the paper:</p> <pre><code>mu_ratio = sinXi_sin_mu / sp.collect(sinXi_cos_mu, cos(iota-theta))\nprint_eq( r\"\\tan(\\mu)\", sp.simplify( mu_ratio.subs(sin(sigma), tan(sigma)*cos(sigma)) ) )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\mu) = \\frac{\\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\cos{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )}}{\\left(\\sin{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )}} \\nonumber         \\end{equation}         \\] <p>Now express \\(S\\) in terms of \\(\\mu\\) on the \\(\\{n\\}\\) basis. First remind myself what \\(S\\) looks like:</p> <pre><code>print_bivec(\"S\", S)\n</code></pre> \\[\\displaystyle              \\begin{align}             S &amp; = \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} e_1 \\wedge e_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_1 \\wedge e_3 \\nonumber \\\\             &amp; + - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} e_2 \\wedge e_3 \\nonumber             \\end{align}             \\] <p>and save nice forms of the \\(n\\) bivectors</p> <pre><code>n12 = mv.Mv(sp.trigsimp(sp.expand_trig((n1^n2).obj)), ga=G3)\nn13 = mv.Mv(sp.trigsimp(sp.expand_trig((n1^n3).obj)), ga=G3)\nn23 = mv.Mv(sp.trigsimp(sp.expand_trig((n2^n3).obj)), ga=G3)\n</code></pre> <p>So now can check each component of S on the \\(n\\) basis</p> <pre><code>Sn_check = (S|n12) + (-sinXi_sin_mu*sin(iota)) == (S|n13) + sinXi_cos_mu == (S|n23) + (-sinXi_sin_mu*cos(iota)) == mv.Mv(0, ga=G3)\nassert Sn_check\nSn_check\n</code></pre> <pre><code>True\n</code></pre> <p>and confirm S in this form</p> <pre><code>S_check = S - (-sinXi_sin_mu*(sin(iota)*n12 + cos(iota)*n23) + sinXi_cos_mu*n13)\nassert S_check.obj.equals(0)\ndisplay( S_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>so can capture S in terms of the surface-frame bivectors</p> <pre><code>Xi = sp.Symbol(\"\\Xi\")\nSu = sin(Xi)*( -sin(mu) * (sin(iota)*(u1^u2) + cos(iota)*(u2^u3)) + cos(mu)*(u1^u3) )\nprint_eq( \"S_u\", Su)\n</code></pre> \\[\\displaystyle          \\begin{equation}             S_u = - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{2} + \\sin{\\left (\\Xi \\right )} \\cos{\\left (\\mu  \\right )} \\boldsymbol{u}_{1}\\wedge \\boldsymbol{u}_{3} - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} \\boldsymbol{u}_{2}\\wedge \\boldsymbol{u}_{3} \\nonumber         \\end{equation}         \\] <p>Check that \\(S_u\\) and \\(S\\) are really the same thing</p> <pre><code>def e_frame(bvec):\n    \"\"\"\n    Take a bivector in the GA defined by the surface frame n1, n2, n3 (written as u1, u2, u3)\n    and express it in the GA defined by the frame of the fixed stars, e1, e2, e3\n    \"\"\"\n    coeffs = bvec.get_coefs(2)\n    return coeffs[0]*n12 + coeffs[1]*n13 + coeffs[2]*n23\n\nSu_check = e_frame(Su).subs(sin(mu), sinXi_sin_mu/sin(Xi)).subs(cos(mu), sinXi_cos_mu/sin(Xi)) - S\nassert Su_check.obj.equals(0)\ndisplay( Su_check )\n</code></pre> \\[\\displaystyle  0 \\]"},{"location":"sundial/#the-shadow-angle","title":"The Shadow Angle","text":"<p>Form a vector parallel to the shadow, as the intersection between \\(S\\) (the plane containing the sun ray and the gnomon) and \\(G\\) (the dial face)</p> <pre><code>u = ((u1^u2^u3) * Gu * Su).get_grade(1).trigsimp()\nprint_vec(\"u\", u, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             u &amp; = \\sin{\\left (\\Xi \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\sin{\\left (\\Xi \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} u_1 \\nonumber \\\\             &amp; + - \\sin{\\left (\\Xi \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} - \\sin{\\left (\\Xi \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )} u_2 \\nonumber \\\\             &amp; + - \\sin{\\left (\\Xi \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\Xi \\right )} \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )} u_3 \\nonumber             \\end{align}             \\] <p>Want to normalize \\(u\\) to get \\(\\hat{u} \\equiv \\hat{w}\\), a unit vector parallel to the shadow \\(w\\). Can square and add the above components, but there is a route to a simpler expression as follows.</p> <p>The cosine of the angle between the \"shadow plane\" \\(S\\) (containing the sun ray \\(s\\) and the gnomon \\(g\\)) and dial face \\(G\\) is given by</p> \\[\\cos(\\Psi) = \\frac{S\\cdot G}{\\sqrt{-S^2}\\sqrt{-G^2}}\\] <p>Given that \\(S^2 = -\\sin^2(\\Xi)\\) and \\(G^2 = -1\\),</p> \\[ \\cos(\\Psi) = \\frac{S\\cdot G}{\\sin(\\Xi)}\\] <pre><code>cosPsi = sp.trigsimp(((Su|Gu)/sin(Xi)).obj)\nprint_eq(r\"\\cos(\\Psi)\", cosPsi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\Psi) = - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (i \\right )} \\nonumber         \\end{equation}         \\] <pre><code># check (force sympy to give up the positive square root in each factor in the denominator)\nSuGu_check = sp.trigsimp((Su|Gu).obj) \\\n/ sp.powdenest(sp.sqrt(sp.trigsimp((-Su|Su).obj)), force=True) \\\n/ sp.powdenest(sp.sqrt(sp.trigsimp((-Gu|Gu).obj)), force=True) \\\n- ((Su|Gu)/sin(Xi))\nassert SuGu_check.obj.equals(0)\ndisplay( SuGu_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Now, the length of \\(u\\) is related to \\(\\Psi\\) as follows.</p> \\[u^2 = (I\\; G \\times S)^2 = (\\frac{I}{2}(GS-SG))^2 = -\\frac{1}{4}(GSGS+SGSG-2S^2G^2)\\] <p>But</p> \\[(S\\cdot G)^2 = \\frac{1}{4}(SG+GS)^2 = \\frac{1}{4}(SGSG+GSGS+2S^2G^2)\\] <p>So,</p> \\[u^2 = S^2G^2 - (S\\cdot G)^2 = \\sin^2(\\Xi) - (S\\cdot G)^2 = \\sin^2(\\Xi)\\sin^2(\\Psi)\\] <pre><code># check\nu2_check = (u|u) - (sin(Xi)**2 - (Su|Gu)**2)\nassert u2_check.obj.equals(0)\ndisplay( u2_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>We can now form \\(\\hat{w}\\) by dividing \\(u\\) by its length</p> <pre><code>Psi = sp.Symbol(\"\\Psi\")\nwhat = u/sin(Xi)/sin(Psi)\n\nprint_vec(r\"\\hat{w}\", what, \"u\", sp.factor)\n</code></pre> \\[\\displaystyle              \\begin{align}             \\hat{w} &amp; = \\frac{\\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} u_1 \\nonumber \\\\             &amp; + - \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} u_2 \\nonumber \\\\             &amp; + \\frac{\\left(- \\sin{\\left (d \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )}\\right) \\sin{\\left (i \\right )}}{\\sin{\\left (\\Psi \\right )}} u_3 \\nonumber             \\end{align}             \\] <p>Check that</p> \\[\\hat{w}^2 = \\left(\\frac{u}{\\sin(\\Xi)\\sin(\\Psi)}\\right)^2 = 1\\] <p>by showing that</p> \\[\\frac{u^2}{\\sin^2(\\Xi)} - \\sin^2\\Psi = 0\\] <pre><code>sinPsiSquared = 1 - sp.expand(cosPsi**2)\nu_over_sinXi_squared = sp.trigsimp(((u|u)/sin(Xi)**2).obj)\nwhat_check = sp.trigsimp(u_over_sinXi_squared - sinPsiSquared)\nassert what_check.equals(0)\ndisplay( what_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Get the angular coordinate of the shadow tip relative to noon, call it \\(\\zeta\\). At noon we have \\(\\mu = 0\\)</p> <pre><code>sinPsi_noon = sp.sqrt(1-cosPsi**2).subs(mu,0)\ndisplay( sinPsi_noon )\n</code></pre> \\[\\displaystyle \\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}\\] <pre><code>noon = what.subs(sin(Psi),sinPsi_noon).subs(mu,0)\ndisplay( noon )\n</code></pre> \\[\\displaystyle \\frac{\\cos{\\left (i \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}} \\boldsymbol{u}_{1} + \\frac{\\sin{\\left (i \\right )} \\cos{\\left (d \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1}} \\boldsymbol{u}_{3}\\] <p>So \\(\\cos(\\zeta) = \\hat{w}(\\mu) \\cdot \\hat{w}(0)\\)</p> <pre><code>cos_zeta = sp.collect(sp.collect(sp.trigsimp((what|noon).obj),sin(mu)*sin(i)*sin(d)),cos(mu))\nprint_eq( r\"\\cos(\\zeta)\", cos_zeta )\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\zeta) = \\frac{\\left(- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1\\right) \\cos{\\left (\\mu  \\right )} + \\left(- \\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} + \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1} \\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <p>And easiest route to \\(\\sin(\\zeta)\\) is to use the fact that the shadow lives in the plane of the dial face, so \\(\\hat{w}(\\mu) \\wedge \\hat{w}(0) = \\sin(\\zeta) G\\)</p> <pre><code>sin_zeta = -(what ^ noon) | Gu\nprint_eq(r\"\\sin(\\zeta)\", sin_zeta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\zeta) = \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\mu  \\right )}}{\\sqrt{- {\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + 1} \\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>tan_zeta = (sin_zeta/cos_zeta).subs(sin(mu), tan(mu)*cos(mu))\nprint_eq(r\"\\tan(\\zeta)\", tan_zeta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\zeta) = - \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\tan{\\left (\\mu  \\right )}}{{\\sin{\\left (d \\right )}}^{2} {\\sin{\\left (i \\right )}}^{2} + \\sin{\\left (d \\right )} {\\sin{\\left (i \\right )}}^{2} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} \\tan{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )} \\tan{\\left (\\mu  \\right )} - 1} \\nonumber         \\end{equation}         \\] <p>Check that \\(\\sin^2(\\zeta) + \\cos^2(\\zeta) = 1\\)</p> <pre><code>sp.simplify(sp.expand( sp.trigsimp(sin_zeta.obj)**2 + cos_zeta**2 ))\n</code></pre> \\[\\displaystyle \\frac{- \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} + 2 \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\mu \\right)} - \\sin^{2}{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} - 2 \\sin{\\left(d \\right)} \\sin^{2}{\\left(i \\right)} \\sin{\\left(\\mu \\right)} \\cos{\\left(d \\right)} \\cos{\\left(\\iota \\right)} \\cos{\\left(\\mu \\right)} + 2 \\sin{\\left(d \\right)} \\sin{\\left(i \\right)} \\sin{\\left(\\iota \\right)} \\sin{\\left(\\mu \\right)} \\cos{\\left(i \\right)} \\cos{\\left(\\mu \\right)} + 2 \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} - \\sin^{2}{\\left(i \\right)} \\sin^{2}{\\left(\\mu \\right)} + 2 \\sin{\\left(i \\right)} \\sin{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} \\cos{\\left(d \\right)} \\cos{\\left(i \\right)} \\cos{\\left(\\iota \\right)} - \\sin^{2}{\\left(\\iota \\right)} \\sin^{2}{\\left(\\mu \\right)} + 1}{\\sin^{2}{\\left(\\Psi \\right)}}\\] <p>This is 1 if the numerator is equal to the denominator, and we have an explicit expression for \\(\\cos(\\Psi) = \\sqrt{1 - \\sin^2(\\Psi)}\\). So should get zero from the following:</p> <pre><code>zeta_check = sp.trigsimp(sp.numer(_) - (1-cosPsi**2))\nassert zeta_check.equals(0)\ndisplay( zeta_check )\n</code></pre> \\[\\displaystyle 0\\]"},{"location":"sundial/#the-shadow-length","title":"The Shadow Length","text":"<p>We have the angle of the shadow vector \\(w\\). Now find the length. Form \\(w(p) = g + p*s\\) and enforce \\(w(p) \\wedge G = 0\\) (used \\(\\lambda\\) instead of \\(p\\) in the paper but can't here because it's a keyword in Python).</p> <pre><code>G = e_frame(Gu)\ntriangle_condition = ((g + p*s)^G) * I\ndisplay( triangle_condition )\n</code></pre> \\[\\displaystyle p \\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - p \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + p \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + p \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - p \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} - \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\] <pre><code>p_soln = sp.solve(sp.trigsimp(triangle_condition.obj), p)[0]\ndisplay( p_soln )\n</code></pre> \\[\\displaystyle \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}}\\] <p>Now to simplify the denominator. Writing \\(p = \\frac{N}{D}\\), we can write \\(D\\) in terms of the hour angle \\(\\mu\\) (and sunray-gnomon angle \\(\\Xi\\)) evaluated under the condition \\(\\iota = \\theta\\) and denoted \\(\\mu_s\\) (and \\(\\Xi_s\\)). This is true when the gnomon is parallel to the earth's axis, and termed a style, hence the subscript \\(s\\).</p> <pre><code>mu_s = sp.Symbol(r\"\\mu_s\")\nXi_s = sp.Symbol(r\"\\Xi_s\")\nD_soln = sin(Xi_s) * ((sin(i)*cos(d)*cos(theta)-cos(i)*sin(theta)) * cos(mu_s) - sin(i)*sin(d)*sin(mu_s)) + sin(alpha)*cos(sigma)*( sin(i)*sin(theta)*cos(d) + cos(i)*cos(theta) )\nprint_eq( \"D\", D_soln )\n</code></pre> \\[\\displaystyle          \\begin{equation}             D = \\left(\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu_{s} \\right )} - \\sin{\\left (\\mu_{s} \\right )} \\sin{\\left (d \\right )} \\sin{\\left (i \\right )}\\right) \\sin{\\left (\\Xi_{s} \\right )} + \\left(\\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\nonumber         \\end{equation}         \\] <pre><code># check\nD_explicit = sp.simplify(D_soln.subs(mu_s,mu).subs(Xi_s,Xi).subs(sin(mu),sinXi_sin_mu/sin(Xi)).subs(cos(mu),sinXi_cos_mu/sin(Xi)).subs(iota,theta))\nD_check = sp.simplify(sp.denom(p_soln) - D_explicit)\nassert D_check.equals(0)\ndisplay( D_check )\n</code></pre> \\[\\displaystyle 0\\] <p>The factorization implicit in the above expression remains when \\(\\mu_s\\) and \\(\\Xi_s\\) are eliminated</p> <pre><code>print_eq( \"D\", D_explicit )\n</code></pre> \\[\\displaystyle          \\begin{equation}             D = \\left(\\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}\\right) \\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )}\\right) + \\left(\\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\left(\\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\nonumber         \\end{equation}         \\] <p>Check:</p> <pre><code>D_explicit_check = sp.simplify(sp.denom(p_soln) - D_explicit)\nassert D_explicit_check.equals(0)\ndisplay( D_explicit_check )\n</code></pre> \\[\\displaystyle 0\\] <p>So given \\(p\\), we have \\(w = g + ps\\). However, it is a little cumbersome to work with and we can get \\(w\\) in terms of \\(g\\)-\\(ps\\)-\\(w\\) triangle directly by projecting \\(w\\) onto \\(s\\) and \\(g\\) to give two equations we can solve for \\(p\\) and \\(L\\), the length of \\(w\\). We have</p> \\[s\\cdot w = L\\cos(\\Xi-\\beta) = s\\cdot g + p\\, s\\cdot s = \\cos(\\Xi) + p\\] <p>and</p> \\[g\\cdot w = L\\cos(\\beta) = g\\cdot g + p g\\cdot s = 1 + p\\, \\cos(\\Xi)\\] <p>This yields two simultaneous equations for \\(p\\) and \\(L\\), with solutions</p> \\[p = \\frac{\\sin(\\beta)}{\\sin(\\Xi-\\beta)}\\] <p>and</p> \\[L = \\frac{\\sin(\\Xi)}{\\sin(\\Xi-\\beta)}\\] <p>First define \\(w\\) on the \\(n\\) basis</p> <pre><code>wu = gu + p*su\nprint_vec(\"w\", wu, \"u\")\n</code></pre> \\[\\displaystyle              \\begin{align}             w &amp; = p \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + p \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\iota  \\right )} u_1 \\nonumber \\\\             &amp; + - p \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + p \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} u_2 \\nonumber \\\\             &amp; + - p \\sin{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + p \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} + p \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} + \\cos{\\left (\\iota  \\right )} u_3 \\nonumber             \\end{align}             \\] <p>Then check that \\(p + \\cos(\\Xi)\\) is equal to the projection of \\(w\\) onto \\(s\\)</p> <pre><code>ws_check = (su|wu) - (p + cosXi)\nassert ws_check.obj.equals(0)\ndisplay( ws_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Now check that \\(1 + p\\cos(\\Xi)\\) is equal to the projection of \\(w\\) onto \\(g\\)</p> <pre><code>wg_check = (gu|wu) - (1 + p*cosXi)\nassert wg_check.obj.equals(0)\ndisplay( wg_check )\n</code></pre> \\[\\displaystyle  0 \\] <p>Given that \\(\\sin(\\beta)\\) appears in the solution for \\(p\\), it will be useful to have its explicit form, which is</p> <pre><code>sin_beta = (sin(i)*sin(iota)*cos(d) + cos(i)*cos(iota))/sin(Psi)\nprint_eq(r\"\\sin(\\beta)\", sin_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\beta) = \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <p>Confirm this by checking that \\(\\sin^2(\\beta) + \\cos^2(\\beta) - 1 = 0\\)</p> <pre><code>cos_beta = sp.collect(sp.trigsimp((gu|what).obj), cos(mu))\nprint_eq(r\"\\cos(\\beta)\", cos_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\cos(\\beta) = \\frac{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>beta_check = sp.trigsimp(sp.expand(sp.numer(sin_beta)**2 + sp.numer(cos_beta)**2) - (1-cosPsi**2))\nassert beta_check.equals(0)\ndisplay( beta_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Give \\(\\tan(\\beta)\\) as in the paper</p> <pre><code>print_eq(r\"\\tan(\\beta)\", sin_beta/cos_beta)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\tan(\\beta) = \\frac{\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}} \\nonumber         \\end{equation}         \\] <p>We can now use the form of \\(p\\) found by solving \\(w\\wedge G = 0\\) to obtain \\(\\sin(\\Xi)\\). First note that \\(N\\), the numerator of \\(p\\), is related to \\(\\beta\\) via</p> \\[\\sin(\\beta) = \\frac{N}{\\sin(\\Psi)}\\] <p>Check</p> <pre><code>sin_beta_check = sp.numer(p_soln)/sin(Psi) - sin_beta\nassert sin_beta_check.equals(0)\ndisplay( sin_beta_check )\n</code></pre> \\[\\displaystyle 0\\] <p>Given our solution for \\(p\\), we can write</p> \\[p = \\frac{\\sin(\\beta)}{\\sin(\\Xi-\\beta)} = \\frac{N}{D}\\] <p>Eliminating \\(N\\) using the above relationship with \\(\\beta\\) and solving for \\(D\\) gives</p> \\[D = \\sin(\\Psi)\\sin(\\Xi-\\beta)\\] <p>Note that using this to eliminate \\(\\sin(\\Xi-\\beta)\\) in our solution for \\(L\\) gives</p> \\[L = \\frac{\\sin(\\Xi)\\sin(\\Psi)}{D}\\] <p>Expanding the double angle in \\(D\\) and solving for \\(\\sin(\\Xi)\\) gives</p> \\[\\sin(\\Xi) = \\frac{D + N\\cos(\\Xi)}{B}\\] <p>where</p> \\[\\cos(\\beta) = \\frac{B}{\\sin(\\Psi)}\\] <p>Thus</p> <pre><code>tmp = (sp.denom(p_soln) + sin(beta)*sin(Psi)*cos(Xi))/(cos(beta)*sin(Psi))\nsinXi = tmp.subs(sin(beta),sin_beta).subs(cos(beta),cos_beta)\nprint_eq( r\"\\sin(\\Xi)\", sinXi)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\sin(\\Xi) = \\frac{\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\cos{\\left (\\Xi \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )}}{\\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} - \\sin{\\left (\\iota  \\right )} \\cos{\\left (i \\right )}\\right) \\cos{\\left (\\mu  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\mu  \\right )}} \\nonumber         \\end{equation}         \\]"},{"location":"sundial/#the-shadow-coordinates","title":"The Shadow Coordinates","text":"<p>Let's now get the cartesian coordinates of the shadow tip in the dial face frame.</p> \\[w = L \\hat{w}\\] <p>and so can work with \\(\\hat{w}\\) and scale up by after.</p> <pre><code>print_eq(r\"\\frac{x}{L}\", what|m1)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{x}{L} = \\frac{- \\sin{\\left (d \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>print_eq(r\"\\frac{y}{L}\", mv.Mv(sp.trigsimp(sp.expand_trig((what|m2).obj)), ga=G3u))\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{y}{L} = - \\frac{\\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}}{\\sin{\\left (\\Psi \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>print_eq(r\"\\frac{z}{L}\", what|m3)\n</code></pre> \\[\\displaystyle          \\begin{equation}             \\frac{z}{L} =  0  \\nonumber         \\end{equation}         \\] <p>Check:</p> <pre><code>assert (what|m1).obj.trigsimp().equals((-sin(d)*sin(mu)*cos(iota)+cos(d)*cos(mu))/sin(Psi))\nassert (what|m2).obj.trigsimp().equals(-(sin(d)*cos(i)*cos(mu)+sin(i)*sin(iota)*sin(mu)+sin(mu)*cos(d)*cos(i)*cos(iota))/sin(Psi))\nassert (what|m3).obj.trigsimp().equals(0)\n</code></pre> <p>By substituting for \\(L\\) using</p> \\[L = \\frac{\\sin(\\Xi)\\sin(\\Psi)}{D}\\] <p>we obtain</p> <pre><code>x_shadow = (what|m1) * sin(Psi) * sin(Xi) / D\nprint_eq(r\"x\", x_shadow)\n</code></pre> \\[\\displaystyle          \\begin{equation}             x = \\frac{\\left(- \\sin{\\left (d \\right )} \\sin{\\left (\\mu  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\mu  \\right )}\\right) \\sin{\\left (\\Xi \\right )}}{D} \\nonumber         \\end{equation}         \\] <pre><code>y_shadow = mv.Mv(sp.trigsimp(sp.expand_trig((what|m2).obj)), ga=G3u) * sin(Psi) * sin(Xi) / D\nprint_eq(r\"y\", y_shadow)\n</code></pre> \\[\\displaystyle          \\begin{equation}             y = - \\frac{\\left(\\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\mu  \\right )} + \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\sin{\\left (\\mu  \\right )} + \\sin{\\left (\\mu  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\Xi \\right )}}{D} \\nonumber         \\end{equation}         \\] <p>We have explicit forms for \\(\\sin(\\Xi)\\sin(\\mu)\\), \\(\\sin(\\Xi)\\cos(\\mu)\\) and \\(D\\), allowing the shadow coordinates to be expressed in terms of the Earth's orientation parameters \\(\\alpha\\), \\(\\sigma\\), and \\(\\psi\\), together with the sundial parameters \\(\\theta\\), \\(i\\), \\(d\\) and \\(\\iota\\):</p> <pre><code>def _simplify_shadow_coord_terms(term):\n    term = term.subs(sin(mu), sinXi_sin_mu/sin(Xi)).subs(cos(mu), sinXi_cos_mu/sin(Xi)).simplify().obj\n    term = term.subs(sin(sigma), tan(sigma)*cos(sigma)).simplify()\n    return sp.collect(sp.collect(sp.collect(term, cos(psi)), sin(psi)), tan(sigma))\n\nx_explicit = _simplify_shadow_coord_terms((what|m1) * sin(Psi) * sin(Xi)) / D_explicit.subs(sin(sigma), tan(sigma)*cos(sigma)).simplify()\nprint_eq(r\"x\", x_explicit)\n</code></pre> \\[\\displaystyle          \\begin{equation}             x = \\frac{\\left(- \\sin{\\left (d \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\tan{\\left (\\sigma  \\right )}\\right) \\sin{\\left (\\psi  \\right )} + \\left(\\sin{\\left (d \\right )} \\cos{\\left (\\iota  \\right )} \\tan{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right) \\cos{\\left (\\psi  \\right )} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (d \\right )}}{- \\left(\\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\cos{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )}\\right) \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} + \\left(\\sin{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )}\\right) + \\left(\\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\sin{\\left (\\alpha  \\right )}} \\nonumber         \\end{equation}         \\] <pre><code>def _simplify_shadow_coord_terms(term):\n    term = term.subs(sin(mu), sinXi_sin_mu/sin(Xi)).subs(cos(mu), sinXi_cos_mu/sin(Xi)).simplify().obj\n    term = term.subs(sin(sigma), tan(sigma)*cos(sigma)).simplify()\n    return sp.collect(sp.collect(sp.collect(term, cos(psi)), sin(psi)), tan(sigma))\n\ny_explicit = _simplify_shadow_coord_terms(mv.Mv(sp.trigsimp(sp.expand_trig((what|m2).obj) * sin(Psi) * sin(Xi)), ga=G3u)) / D_explicit.subs(sin(sigma), tan(sigma)*cos(sigma)).simplify()\nprint_eq(r\"y\", y_explicit)\n</code></pre> \\[\\displaystyle          \\begin{equation}             y = \\frac{\\left(\\left(\\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} + \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\tan{\\left (\\sigma  \\right )} - \\sin{\\left (d \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  - \\theta  \\right )}\\right) \\cos{\\left (\\psi  \\right )} + \\left(- \\sin{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  - \\theta  \\right )} \\tan{\\left (\\sigma  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\iota  \\right )} \\cos{\\left (\\alpha  \\right )} - \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\iota  \\right )}\\right) \\sin{\\left (\\psi  \\right )} + \\sin{\\left (\\alpha  \\right )} \\sin{\\left (d \\right )} \\sin{\\left (\\iota  - \\theta  \\right )} \\cos{\\left (i \\right )}}{- \\left(\\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} - \\cos{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )}\\right) \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} + \\left(\\sin{\\left (\\psi  \\right )} \\tan{\\left (\\sigma  \\right )} + \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\psi  \\right )}\\right) \\left(\\sin{\\left (i \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )}\\right) + \\left(\\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} + \\cos{\\left (i \\right )} \\cos{\\left (\\theta  \\right )}\\right) \\sin{\\left (\\alpha  \\right )}} \\nonumber         \\end{equation}         \\]"},{"location":"sundial/#angle-between-sun-ray-and-dial-face","title":"Angle Between Sun Ray and Dial Face","text":"<p>It will be important for plotting analemmas to determine an effective sunrise and sunset for the given sundial, defined as the points in the sun's journey across the sky when the angle between the sun ray \\(s\\) and dial face \\(G\\) is zero (or \\(\\pi\\)). This angle is given by \\(\\(-(G\\wedge s) \\cdot I\\)\\)</p> <pre><code>-(G^s)|I\n</code></pre> \\[\\begin{equation*} - \\sin{\\left (\\alpha  \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (\\sigma  \\right )} - \\sin{\\left (d \\right )} \\sin{\\left (i \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (\\psi  \\right )} - \\sin{\\left (i \\right )} \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\theta  \\right )} - \\sin{\\left (i \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (d \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\cos{\\left (\\theta  \\right )} + \\sin{\\left (\\psi  \\right )} \\sin{\\left (\\sigma  \\right )} \\sin{\\left (\\theta  \\right )} \\cos{\\left (i \\right )} + \\sin{\\left (\\theta  \\right )} \\cos{\\left (\\alpha  \\right )} \\cos{\\left (i \\right )} \\cos{\\left (\\psi  \\right )} \\cos{\\left (\\sigma  \\right )} \\end{equation*}\\]"},{"location":"sundial/#test-sundial-module","title":"Test <code>sundial</code> Module","text":"<p>Check consistency with <code>sundial</code> Python module.</p> <pre><code>import sundial as sd\nfrom sympy import utilities as util\nimport math, numpy as np\n\nargs = {\"alpha\":sd.earth.alpha, \"sigma\":np.pi/2.4, \"psi\":np.pi/27, \"iota\":np.pi/7, \"theta\":np.pi/9, \"i\":np.pi/40, \"d\":np.pi/43}\n\nx_num = util.lambdify(args.keys(), x_explicit)\nx_val = x_num(**args)\n\ny_num = util.lambdify(args.keys(), y_explicit)\ny_val = y_num(**args)\n\n(x_py_val, y_py_val) = sd.shadow_coords_xy(**args)\n\nassert math.isclose(x_val, x_py_val)\nassert math.isclose(y_val, y_py_val)\n</code></pre>"},{"location":"sundial_plots/","title":"Analemma Plots","text":"<p>This notebook uses the results from Sundial Calculations as encoded in the analemma package to visualize various properties of sundials, in particular analemmas.</p> <pre><code>from analemma import orbit, plot as aplot\nimport matplotlib.pyplot as plt\nimport numpy as np\n\npi = np.pi\nearth = orbit.PlanetParameters.earth()\ncamdial = aplot.DialParameters(theta=37.5/180*pi, iota=37.5/180*pi, i=0, d=0) # Analemmatic dial in Cambridge, UK\n</code></pre>"},{"location":"sundial_plots/#sunrise-and-sunset","title":"Sunrise and Sunset","text":"<p>We will need to know the range of time within each day to plot the path of the tip of the shadow as the sun moves through the sky. This is determined by the angle between the sun ray and the face of the dial. When the sun ray and dial face are parallel, we have an effective sunrise or sunset relative to the dial. When the sun ray is closest to perpendicular to the dial face, we have an effective noon relative to the dial. For some dials on some days, such points do not exist and there is either a shadow throughout the entire day or the lack thereof.</p> <pre><code>days_since_perihelion = 50\nst = aplot.find_sun_rise_noon_set_relative_to_dial_face(days_since_perihelion, earth, camdial)\n\ntimes = st.sample_times_for_one_day()\nabs_seconds = np.array([st.absolute_seconds for st in times])\nsines = aplot.sin_sunray_dialface_angle(abs_seconds, earth, camdial)\n\nfig, ax = plt.subplots()\nax.plot([st.hours_from_midnight for st in times], sines)\nax.plot(st.sunrise.hours_from_midnight, aplot.sin_sunray_dialface_angle(st.sunrise.absolute_seconds, earth, camdial), 'sr', label=\"Sunrise\")\nax.plot(st.noon.hours_from_midnight,    aplot.sin_sunray_dialface_angle(st.noon.absolute_seconds, earth, camdial), 'og', label=\"Noon\")\nax.plot(st.sunset.hours_from_midnight,  aplot.sin_sunray_dialface_angle(st.sunset.absolute_seconds, earth, camdial), 'Db', label=\"Sunset\")\nax.grid()\nax.set_xlabel(\"Time in hours since midnight\")\nax.set_ylabel(\"Sine of sunray-dialface angle\")\nax.set_title(f\"Key sundial events on {aplot.orbit_day_to_date(days_since_perihelion)}\")\nax.legend()\n</code></pre> <pre><code>&lt;matplotlib.legend.Legend at 0x1337f2c70&gt;\n</code></pre> <p></p>"},{"location":"sundial_plots/#the-solstices","title":"The Solstices","text":"<p>The June and December solstices should occur on the longest and shortest day of the year for the given dial.</p> <pre><code>import datetime\n\nsun_times = [aplot.find_sun_rise_noon_set_relative_to_dial_face(days_since_perihelion, earth, camdial) for days_since_perihelion in np.arange(0, 365)]\n\nday_lengths = [st.sunset.hours_from_midnight - st.sunrise.hours_from_midnight for st in sun_times]\ndecember_solstice = np.argmin(day_lengths)\njune_solstice = np.argmax(day_lengths)\n\nassert aplot.orbit_day_to_date(0) == datetime.date.fromisoformat(\"2024-01-03\")\nassert aplot.orbit_day_to_date(june_solstice) == datetime.date.fromisoformat(\"2024-06-21\")\nassert aplot.orbit_day_to_date(december_solstice) == datetime.date.fromisoformat(\"2024-12-21\")\n\nassert aplot.orbit_date_to_day(datetime.date.fromisoformat(\"2024-01-03\")) == 0\nassert aplot.orbit_date_to_day(datetime.date.fromisoformat(\"2024-06-21\")) == june_solstice\nassert aplot.orbit_date_to_day(datetime.date.fromisoformat(\"2024-12-21\")) == december_solstice\n\narbitrary_date = datetime.date.fromisoformat(\"2024-05-26\")\nassert aplot.orbit_day_to_date(aplot.orbit_date_to_day(arbitrary_date)) == arbitrary_date\n</code></pre>"},{"location":"sundial_plots/#daytime","title":"Daytime","text":"<p>An effective daytime relative to the dial exists when the sine of the sunray-dialface angle is positive.</p> <pre><code>def _plot_sunray_dialface_angle(ax, begin_hour, end_hour, planet : orbit.PlanetParameters, dial : aplot.DialParameters):\n    for hour_offset in np.arange(begin_hour, end_hour):\n        times, sines = aplot.sunray_dialface_angle_over_one_year(planet, dial, hour_offset)\n        ax.plot(times/3600/24, sines, label=aplot.hour_offset_to_oclock(hour_offset))\n    ax.grid()\n    ax.legend()\n    ax.set_xlabel(\"Days since perihelion\")\n\n\nfig, ax = plt.subplots(1, 2, figsize=(12, 5))\n\n_plot_sunray_dialface_angle(ax[0], -12, 0, earth, camdial)\nax[0].set_ylabel(\"Sine of sunray-dialface angle\")\n_plot_sunray_dialface_angle(ax[1], 0, 12, earth, camdial)\n\nfig.suptitle(\"Daytime throughout the year\")\n</code></pre> <pre><code>Text(0.5, 0.98, 'Daytime throughout the year')\n</code></pre> <p></p>"},{"location":"sundial_plots/#analemmas","title":"Analemmas","text":"<p>The analemma is the path traced by the sun in the sky, or the shadow on a sundial, throughout one year when viewed at the same time each day, and typically has a figure-of-eight shape, because of the equation of time.</p> <p>In the plots below we show several analemmas, one per hour of daytime. The line style shows the season. One line showing the path of the shadow tip during the day for each solstice is also shown (with line style appropriate to the season) and forms an envelope marking the longest shadows in Winter and the shortest shadows in Summer. Similarly, the path of the shadow tip on each equinox is shown and appears as a straight line. Moreover, the two straight lines fall on top of each other.</p> <p>A black circle marks the base of the gnomon, which has unit length.</p> <pre><code>fig, ax = plt.subplots(figsize=(12, 10))\nax.grid()\nax.axis(\"equal\")\n\nhour_offsets = aplot.find_daytime_offsets(earth, camdial)\n\nlines_for_legend = []\nfor season in aplot.Season:\n    for hour in hour_offsets:\n        aplot.plot_analemma_season_segment(ax, season, hour, earth, camdial, linewidth=0.75)\n        aplot.annotate_analemma_with_hour(ax, hour, earth, camdial)\n    lines_for_legend += aplot.plot_special_sun_path(ax, season, earth, camdial, linewidth=0.75)\n\n# put a circle at the base of the gnomon\nax.plot( 0, 0, 'ok' )\n\nordered_lines = [lines_for_legend[season.value] for season in [aplot.Season.Spring, aplot.Season.Summer, aplot.Season.Autumn, aplot.Season.Winter]]\nax.legend(handles=ordered_lines)\n\nax.set_title(\"Analemmatic sundial in Cambridge, UK\")\n</code></pre> <pre><code>Text(0.5, 1.0, 'Analemmatic sundial in Cambridge, UK')\n</code></pre> <p></p>"}]}